{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"University Course Management System","text":"<p>Full-stack application for managing university courses, schedules, and academic analytics.</p>"},{"location":"#problem","title":"Problem","text":"<p>Students need an efficient way to browse available courses, plan their semester schedules, and receive personalized course recommendations based on their program requirements, completed prerequisites, and preferences. Manual course selection and schedule planning is time-consuming and error-prone, especially when considering prerequisite chains, program requirements, and time preferences.</p>"},{"location":"#solution","title":"Solution","text":"<p>The University Course Management System is a web application that enables students to:</p> <ul> <li>Browse and Search Courses: Filter courses by year, semester, course type (GenEd, Major, Elective), and search by course name</li> <li>View Course Details: See instructor information, time slots, locations, seat availability, and syllabus links</li> <li>Create Draft Schedules: Select courses and build draft semester schedules with conflict detection</li> <li>Get Personalized Recommendations: Receive rule-based semester course recommendations that consider:</li> <li>Program requirements (BSDS schedule template)</li> <li>Prerequisite completion status</li> <li>Gen-Ed cluster requirements (3 courses per cluster group)</li> <li>Student credit standing (Freshman/Sophomore/Junior/Senior)</li> <li>Time preferences (morning/afternoon/evening)</li> <li>Semester availability</li> <li>View Statistics: Access academic performance statistics and analytics with 13+ visualization metrics</li> <li>Save and Manage Schedules: Save multiple draft schedules for future reference</li> </ul>"},{"location":"#expected-outcomes","title":"Expected Outcomes","text":"<ul> <li>Streamlined Course Selection: Students can easily browse and filter courses to find what they need</li> <li>Intelligent Planning: Automated recommendations help students plan optimal semester schedules</li> <li>Prerequisite Compliance: System ensures students only see courses they're eligible to take</li> <li>Time Optimization: Recommendations consider time preferences to build convenient schedules</li> <li>Academic Progress Tracking: Statistics help students understand their academic performance</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<ul> <li>Frontend: React + TypeScript (Vite, Tailwind CSS)</li> <li>Backend: FastAPI (Python) with 50+ REST endpoints</li> <li>Database: PostgreSQL with 20+ tables</li> <li>ETL: Data generation and loading pipeline</li> <li>Infrastructure: Docker &amp; Docker Compose</li> </ul>"},{"location":"#components","title":"Components","text":"<ul> <li>API: FastAPI backend with CRUD operations, recommendations, and statistics</li> <li>APP: React frontend for course browsing and schedule management</li> <li>ETL: Data generation and database initialization</li> <li>Shared: Production-ready recommendation engine</li> <li>Notebook: Jupyter environment for data analysis</li> </ul>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>ETL Documentation - Data generation and loading</li> <li>API Documentation - Backend API reference</li> <li>API Models - Database schema</li> <li>Frontend App - React application guide</li> </ul>"},{"location":"api/","title":"API Documentation","text":""},{"location":"api/#overview","title":"Overview","text":"<p>The API component is a FastAPI-based backend service that provides REST endpoints for the university application.</p>"},{"location":"api/#main-application","title":"Main Application","text":"<p>FastAPI application for University Course Management System. Provides REST API endpoints for managing students, courses, and sections.</p> <p>This module defines all API endpoints including student CRUD operations.</p>"},{"location":"api/#university_app.api.main.create_cluster","title":"<code>create_cluster(cluster, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new cluster record in the database.</p> Input <p>cluster (ClusterCreate): The cluster data to create. db (Session): Database session.</p> Output <p>Cluster: The newly created cluster's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/clusters/\", response_model=Cluster, tags=[\"Clusters\"])\nasync def create_cluster(cluster: ClusterCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new cluster record in the database.\n\n    Input:\n        cluster (ClusterCreate): The cluster data to create.\n        db (Session): Database session.\n\n    Output:\n        Cluster: The newly created cluster's details.\n    \"\"\"\n    db_cluster = ClusterDB(**cluster.model_dump())\n    db.add(db_cluster)\n    db.commit()\n    db.refresh(db_cluster)\n    return db_cluster\n</code></pre>"},{"location":"api/#university_app.api.main.create_course","title":"<code>create_course(course, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new course record in the database.</p> Input <p>course (CourseCreate): The course data to create. db (Session): Database session.</p> Output <p>Course: The newly created course's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If database error occurs</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/courses/\", response_model=Course, tags=[\"Courses\"])\nasync def create_course(course: CourseCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new course record in the database.\n\n    Input:\n        course (CourseCreate): The course data to create.\n        db (Session): Database session.\n\n    Output:\n        Course: The newly created course's details.\n\n    Raises:\n        HTTPException: If database error occurs\n    \"\"\"\n    try:\n        db_course = CourseDB(**course.model_dump())\n        db.add(db_course)\n        db.commit()\n        db.refresh(db_course)\n        return db_course\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.create_coursecluster","title":"<code>create_coursecluster(coursecluster, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new course-cluster relationship record in the database.</p> Input <p>coursecluster (CourseClusterCreate): The relationship data to create. db (Session): Database session.</p> Output <p>CourseCluster: The newly created relationship record.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/coursecluster/\", response_model=CourseCluster, tags=[\"Course Clusters\"])\nasync def create_coursecluster(coursecluster: CourseClusterCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new course-cluster relationship record in the database.\n\n    Input:\n        coursecluster (CourseClusterCreate): The relationship data to create.\n        db (Session): Database session.\n\n    Output:\n        CourseCluster: The newly created relationship record.\n    \"\"\"\n    db_coursecluster = CourseClusterDB(**coursecluster.model_dump())\n    db.add(db_coursecluster)\n    db.commit()\n    db.refresh(db_coursecluster)\n    return db_coursecluster\n</code></pre>"},{"location":"api/#university_app.api.main.create_department","title":"<code>create_department(department, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new department record in the database.</p> Input <p>department (DepartmentCreate): The department data to create. db (Session): Database session.</p> Output <p>Department: The newly created department's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/departments/\", response_model=Department, tags=[\"Departments\"])\nasync def create_department(department: DepartmentCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new department record in the database.\n\n    Input:\n        department (DepartmentCreate): The department data to create.\n        db (Session): Database session.\n\n    Output:\n        Department: The newly created department's details.\n    \"\"\"\n    db_department = DepartmentDB(**department.model_dump())\n    db.add(db_department)\n    db.commit()\n    db.refresh(db_department)\n    return db_department\n</code></pre>"},{"location":"api/#university_app.api.main.create_draft_schedule","title":"<code>create_draft_schedule(schedule_data, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new draft schedule.</p> Input <p>schedule_data (DraftScheduleCreate): The draft schedule data including student_id, name, and section_ids. db (Session): Database session.</p> Output <p>DraftSchedule: The newly created draft schedule.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If student doesn't exist or sections are invalid.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/draft-schedules/\", response_model=DraftSchedule, tags=[\"Draft Schedules\"])\nasync def create_draft_schedule(\n    schedule_data: DraftScheduleCreate,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Create a new draft schedule.\n\n    Input:\n        schedule_data (DraftScheduleCreate): The draft schedule data including student_id, name, and section_ids.\n        db (Session): Database session.\n\n    Output:\n        DraftSchedule: The newly created draft schedule.\n\n    Raises:\n        HTTPException: If student doesn't exist or sections are invalid.\n    \"\"\"\n    # Verify student exists\n    student = db.query(StudentDB).filter(StudentDB.student_id == schedule_data.student_id).first()\n    if student is None:\n        raise HTTPException(status_code=404, detail=\"Student not found\")\n\n    # Verify all sections exist\n    if schedule_data.section_ids:\n        existing_sections = db.query(SectionDB.id).filter(\n            SectionDB.id.in_(schedule_data.section_ids)\n        ).all()\n        existing_section_ids = {sid[0] for sid in existing_sections}\n        invalid_sections = set(schedule_data.section_ids) - existing_section_ids\n        if invalid_sections:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Invalid section IDs: {list(invalid_sections)}\"\n            )\n\n    try:\n        # Create draft schedule\n        new_schedule = DraftScheduleDB(\n            student_id=schedule_data.student_id,\n            name=schedule_data.name\n        )\n        db.add(new_schedule)\n        db.flush()  # Get the ID without committing\n\n        # Add sections to the schedule\n        for section_id in schedule_data.section_ids:\n            schedule_section = DraftScheduleSectionDB(\n                draft_schedule_id=new_schedule.draft_schedule_id,\n                section_id=section_id\n            )\n            db.add(schedule_section)\n\n        db.commit()\n        db.refresh(new_schedule)\n    except HTTPException:\n        db.rollback()\n        raise\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Error creating draft schedule: {str(e)}\")\n\n    return {\n        \"draft_schedule_id\": new_schedule.draft_schedule_id,\n        \"student_id\": new_schedule.student_id,\n        \"name\": new_schedule.name,\n        \"created_at\": new_schedule.created_at.isoformat() if new_schedule.created_at else \"\",\n        \"updated_at\": new_schedule.updated_at.isoformat() if new_schedule.updated_at else None,\n        \"section_ids\": schedule_data.section_ids\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.create_hascourse","title":"<code>create_hascourse(hascourse, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new program-course relationship record in the database.</p> Input <p>hascourse (HasCourseCreate): The relationship data to create. db (Session): Database session.</p> Output <p>HasCourse: The newly created relationship record.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/hascourse/\", response_model=HasCourse, tags=[\"Program Courses\"])\nasync def create_hascourse(hascourse: HasCourseCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new program-course relationship record in the database.\n\n    Input:\n        hascourse (HasCourseCreate): The relationship data to create.\n        db (Session): Database session.\n\n    Output:\n        HasCourse: The newly created relationship record.\n    \"\"\"\n    db_hascourse = HasCourseDB(**hascourse.model_dump())\n    db.add(db_hascourse)\n    db.commit()\n    db.refresh(db_hascourse)\n    return db_hascourse\n</code></pre>"},{"location":"api/#university_app.api.main.create_instructor","title":"<code>create_instructor(instructor, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new instructor record in the database.</p> Input <p>instructor (InstructorCreate): The instructor data to create. db (Session): Database session.</p> Output <p>Instructor: The newly created instructor's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/instructors/\", response_model=Instructor, tags=[\"Instructors\"])\nasync def create_instructor(instructor: InstructorCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new instructor record in the database.\n\n    Input:\n        instructor (InstructorCreate): The instructor data to create.\n        db (Session): Database session.\n\n    Output:\n        Instructor: The newly created instructor's details.\n    \"\"\"\n    db_instructor = InstructorDB(**instructor.model_dump())\n    db.add(db_instructor)\n    db.commit()\n    db.refresh(db_instructor)\n    return db_instructor\n</code></pre>"},{"location":"api/#university_app.api.main.create_location","title":"<code>create_location(location, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new location record in the database.</p> Input <p>location (LocationCreate): The location data to create. db (Session): Database session.</p> Output <p>Location: The newly created location's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/locations/\", response_model=Location, tags=[\"Locations\"])\nasync def create_location(location: LocationCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new location record in the database.\n\n    Input:\n        location (LocationCreate): The location data to create.\n        db (Session): Database session.\n\n    Output:\n        Location: The newly created location's details.\n    \"\"\"\n    db_location = LocationDB(**location.model_dump())\n    db.add(db_location)\n    db.commit()\n    db.refresh(db_location)\n    return db_location\n</code></pre>"},{"location":"api/#university_app.api.main.create_preferred","title":"<code>create_preferred(preferred, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new student-course preference record in the database.</p> Input <p>preferred (PreferredCreate): The preference data to create. db (Session): Database session.</p> Output <p>Preferred: The newly created preference record.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/preferred/\", response_model=Preferred, tags=[\"Preferences\"])\nasync def create_preferred(preferred: PreferredCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new student-course preference record in the database.\n\n    Input:\n        preferred (PreferredCreate): The preference data to create.\n        db (Session): Database session.\n\n    Output:\n        Preferred: The newly created preference record.\n    \"\"\"\n    db_preferred = PreferredDB(**preferred.model_dump())\n    db.add(db_preferred)\n    db.commit()\n    db.refresh(db_preferred)\n    return db_preferred\n</code></pre>"},{"location":"api/#university_app.api.main.create_prerequisites","title":"<code>create_prerequisites(prerequisites, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new prerequisite record in the database.</p> Input <p>prerequisites (PrerequisitesCreate): The prerequisite data to create. db (Session): Database session.</p> Output <p>Prerequisites: The newly created prerequisite record.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/prerequisites/\", response_model=Prerequisites, tags=[\"Prerequisites\"])\nasync def create_prerequisites(prerequisites: PrerequisitesCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new prerequisite record in the database.\n\n    Input:\n        prerequisites (PrerequisitesCreate): The prerequisite data to create.\n        db (Session): Database session.\n\n    Output:\n        Prerequisites: The newly created prerequisite record.\n    \"\"\"\n    db_prerequisites = PrerequisitesDB(**prerequisites.model_dump())\n    db.add(db_prerequisites)\n    db.commit()\n    db.refresh(db_prerequisites)\n    return db_prerequisites\n</code></pre>"},{"location":"api/#university_app.api.main.create_program","title":"<code>create_program(program, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new program record in the database.</p> Input <p>program (ProgramCreate): The program data to create. db (Session): Database session.</p> Output <p>Program: The newly created program's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/programs/\", response_model=Program, tags=[\"Programs\"])\nasync def create_program(program: ProgramCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new program record in the database.\n\n    Input:\n        program (ProgramCreate): The program data to create.\n        db (Session): Database session.\n\n    Output:\n        Program: The newly created program's details.\n    \"\"\"\n    db_program = ProgramDB(**program.model_dump())\n    db.add(db_program)\n    db.commit()\n    db.refresh(db_program)\n    return db_program\n</code></pre>"},{"location":"api/#university_app.api.main.create_recommendation_result","title":"<code>create_recommendation_result(recommendation, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new recommendation result record in the database.</p> Input <p>recommendation (RecommendationResultCreate): The recommendation result data to create. db (Session): Database session.</p> Output <p>RecommendationResult: The newly created recommendation result's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/recommendation-results/\", response_model=RecommendationResult, tags=[\"Recommendations\"])\nasync def create_recommendation_result(\n    recommendation: RecommendationResultCreate,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Create a new recommendation result record in the database.\n\n    Input:\n        recommendation (RecommendationResultCreate): The recommendation result data to create.\n        db (Session): Database session.\n\n    Output:\n        RecommendationResult: The newly created recommendation result's details.\n    \"\"\"\n    db_recommendation = RecommendationResultDB(**recommendation.model_dump())\n    db.add(db_recommendation)\n    db.commit()\n    db.refresh(db_recommendation)\n\n    return {\n        \"id\": db_recommendation.id,\n        \"student_id\": db_recommendation.student_id,\n        \"course_id\": db_recommendation.course_id,\n        \"recommended_section_id\": db_recommendation.recommended_section_id,\n        \"course_name\": db_recommendation.course_name,\n        \"cluster\": db_recommendation.cluster,\n        \"credits\": db_recommendation.credits,\n        \"time_slot\": db_recommendation.time_slot,\n        \"recommendation_score\": db_recommendation.recommendation_score,\n        \"why_recommended\": db_recommendation.why_recommended,\n        \"slot_number\": db_recommendation.slot_number,\n        \"model_version\": db_recommendation.model_version,\n        \"time_preference\": db_recommendation.time_preference,\n        \"semester\": db_recommendation.semester,\n        \"year\": db_recommendation.year,\n        \"created_at\": db_recommendation.created_at.isoformat() if db_recommendation.created_at else \"\",\n        \"updated_at\": db_recommendation.updated_at.isoformat() if db_recommendation.updated_at else None\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.create_section","title":"<code>create_section(section, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new section record in the database.</p> Input <p>section (SectionCreate): The section data to create. db (Session): Database session.</p> Output <p>Section: The newly created section's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If database error occurs</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/sections/\", response_model=Section, tags=[\"Sections\"])\nasync def create_section(section: SectionCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new section record in the database.\n\n    Input:\n        section (SectionCreate): The section data to create.\n        db (Session): Database session.\n\n    Output:\n        Section: The newly created section's details.\n\n    Raises:\n        HTTPException: If database error occurs\n    \"\"\"\n    try:\n        db_section = SectionDB(**section.model_dump())\n        db.add(db_section)\n        db.commit()\n        db.refresh(db_section)\n        return db_section\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.create_student","title":"<code>create_student(student, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new student record in the database.</p> Input <p>student (StudentCreate): The student data to create. db (Session): Database session provided by dependency injection.</p> Output <p>Student: The newly created student's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If database error occurs</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/students/\", response_model=Student, tags=[\"Students\"])\nasync def create_student(student: StudentCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new student record in the database.\n\n    Input:\n        student (StudentCreate): The student data to create.\n        db (Session): Database session provided by dependency injection.\n\n    Output:\n        Student: The newly created student's details.\n\n    Raises:\n        HTTPException: If database error occurs\n    \"\"\"\n    try:\n        db_student = StudentDB(\n            student_name=student.student_name,\n            credit=student.credit,\n            program_name=student.program_name\n        )\n        db.add(db_student)\n        db.commit()\n        db.refresh(db_student)\n        return db_student\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.create_takes","title":"<code>create_takes(takes, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new student enrollment record in the database.</p> Input <p>takes (TakesCreate): The enrollment data to create. db (Session): Database session.</p> Output <p>Takes: The newly created enrollment record.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If database error occurs</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/takes/\", response_model=Takes, tags=[\"Enrollments\"])\nasync def create_takes(takes: TakesCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new student enrollment record in the database.\n\n    Input:\n        takes (TakesCreate): The enrollment data to create.\n        db (Session): Database session.\n\n    Output:\n        Takes: The newly created enrollment record.\n\n    Raises:\n        HTTPException: If database error occurs\n    \"\"\"\n    try:\n        db_takes = TakesDB(**takes.model_dump())\n        db.add(db_takes)\n        db.commit()\n        db.refresh(db_takes)\n        return db_takes\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.create_timeslot","title":"<code>create_timeslot(timeslot, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new time slot record in the database.</p> Input <p>timeslot (TimeSlotCreate): The time slot data to create. db (Session): Database session.</p> Output <p>TimeSlot: The newly created time slot's details.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/timeslots/\", response_model=TimeSlot, tags=[\"Time Slots\"])\nasync def create_timeslot(timeslot: TimeSlotCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new time slot record in the database.\n\n    Input:\n        timeslot (TimeSlotCreate): The time slot data to create.\n        db (Session): Database session.\n\n    Output:\n        TimeSlot: The newly created time slot's details.\n    \"\"\"\n    db_timeslot = TimeSlotDB(**timeslot.model_dump())\n    db.add(db_timeslot)\n    db.commit()\n    db.refresh(db_timeslot)\n    return db_timeslot\n</code></pre>"},{"location":"api/#university_app.api.main.create_works","title":"<code>create_works(works, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Create a new instructor-department relationship record in the database.</p> Input <p>works (WorksCreate): The relationship data to create. db (Session): Database session.</p> Output <p>Works: The newly created relationship record.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/works/\", response_model=Works, tags=[\"Works\"])\nasync def create_works(works: WorksCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Create a new instructor-department relationship record in the database.\n\n    Input:\n        works (WorksCreate): The relationship data to create.\n        db (Session): Database session.\n\n    Output:\n        Works: The newly created relationship record.\n    \"\"\"\n    db_works = WorksDB(**works.model_dump())\n    db.add(db_works)\n    db.commit()\n    db.refresh(db_works)\n    return db_works\n</code></pre>"},{"location":"api/#university_app.api.main.delete_cluster","title":"<code>delete_cluster(cluster_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a cluster by its unique ID from the database.</p> Input <p>cluster_id (int): The unique identifier of the cluster to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the cluster is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/clusters/{cluster_id}\", tags=[\"Clusters\"])\nasync def delete_cluster(cluster_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a cluster by its unique ID from the database.\n\n    Input:\n        cluster_id (int): The unique identifier of the cluster to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the cluster is not found, raises a 404 error.\n    \"\"\"\n    cluster = db.query(ClusterDB).filter(ClusterDB.cluster_id == cluster_id).first()\n    if not cluster:\n        raise HTTPException(status_code=404, detail=\"Cluster not found\")\n    db.delete(cluster)\n    db.commit()\n    return {\"message\": \"Cluster deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_course","title":"<code>delete_course(course_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a course by its unique ID from the database.</p> Input <p>course_id (int): The unique identifier of the course to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the course is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/courses/{course_id}\", tags=[\"Courses\"])\nasync def delete_course(course_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a course by its unique ID from the database.\n\n    Input:\n        course_id (int): The unique identifier of the course to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the course is not found, raises a 404 error.\n    \"\"\"\n    course = db.query(CourseDB).filter(CourseDB.id == course_id).first()\n    if not course:\n        raise HTTPException(status_code=404, detail=\"Course not found\")\n    db.delete(course)\n    db.commit()\n    return {\"message\": \"Course deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_coursecluster","title":"<code>delete_coursecluster(course_id, cluster_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a course-cluster relationship record from the database.</p> Input <p>course_id (int): The unique identifier of the course. cluster_id (int): The unique identifier of the cluster. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the relationship is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/coursecluster/\", tags=[\"Course Clusters\"])\nasync def delete_coursecluster(course_id: int, cluster_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a course-cluster relationship record from the database.\n\n    Input:\n        course_id (int): The unique identifier of the course.\n        cluster_id (int): The unique identifier of the cluster.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the relationship is not found, raises a 404 error.\n    \"\"\"\n    coursecluster = db.query(CourseClusterDB).filter(\n        CourseClusterDB.course_id == course_id,\n        CourseClusterDB.cluster_id == cluster_id\n    ).first()\n    if not coursecluster:\n        raise HTTPException(status_code=404, detail=\"Relationship not found\")\n    db.delete(coursecluster)\n    db.commit()\n    return {\"message\": \"Relationship deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_department","title":"<code>delete_department(dept_name, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a department by its name from the database.</p> Input <p>dept_name (str): The name of the department to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the department is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/departments/{dept_name}\", tags=[\"Departments\"])\nasync def delete_department(dept_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a department by its name from the database.\n\n    Input:\n        dept_name (str): The name of the department to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the department is not found, raises a 404 error.\n    \"\"\"\n    department = db.query(DepartmentDB).filter(DepartmentDB.dept_name == dept_name).first()\n    if not department:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    db.delete(department)\n    db.commit()\n    return {\"message\": \"Department deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_draft_schedule","title":"<code>delete_draft_schedule(draft_schedule_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a draft schedule.</p> Input <p>draft_schedule_id (int): The ID of the draft schedule to delete. db (Session): Database session.</p> Output <p>dict: Success message.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the draft schedule is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/draft-schedules/{draft_schedule_id}\", tags=[\"Draft Schedules\"])\nasync def delete_draft_schedule(\n    draft_schedule_id: int,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Delete a draft schedule.\n\n    Input:\n        draft_schedule_id (int): The ID of the draft schedule to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: Success message.\n\n    Raises:\n        HTTPException: If the draft schedule is not found, raises a 404 error.\n    \"\"\"\n    schedule = db.query(DraftScheduleDB).filter(\n        DraftScheduleDB.draft_schedule_id == draft_schedule_id\n    ).first()\n\n    if schedule is None:\n        raise HTTPException(status_code=404, detail=\"Draft schedule not found\")\n\n    # Cascade delete will handle draft_schedule_sections automatically\n    db.delete(schedule)\n    db.commit()\n\n    return {\"message\": \"Draft schedule deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_hascourse","title":"<code>delete_hascourse(prog_name, courseid, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a program-course relationship record from the database.</p> Input <p>prog_name (str): The name of the program. courseid (int): The unique identifier of the course. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the relationship is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/hascourse/\", tags=[\"Program Courses\"])\nasync def delete_hascourse(prog_name: str, courseid: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a program-course relationship record from the database.\n\n    Input:\n        prog_name (str): The name of the program.\n        courseid (int): The unique identifier of the course.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the relationship is not found, raises a 404 error.\n    \"\"\"\n    hascourse = db.query(HasCourseDB).filter(\n        HasCourseDB.prog_name == prog_name,\n        HasCourseDB.courseid == courseid\n    ).first()\n    if not hascourse:\n        raise HTTPException(status_code=404, detail=\"Relationship not found\")\n    db.delete(hascourse)\n    db.commit()\n    return {\"message\": \"Relationship deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_instructor","title":"<code>delete_instructor(instructor_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete an instructor by their unique ID from the database.</p> Input <p>instructor_id (int): The unique identifier of the instructor to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instructor is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/instructors/{instructor_id}\", tags=[\"Instructors\"])\nasync def delete_instructor(instructor_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete an instructor by their unique ID from the database.\n\n    Input:\n        instructor_id (int): The unique identifier of the instructor to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the instructor is not found, raises a 404 error.\n    \"\"\"\n    instructor = db.query(InstructorDB).filter(InstructorDB.id == instructor_id).first()\n    if not instructor:\n        raise HTTPException(status_code=404, detail=\"Instructor not found\")\n    db.delete(instructor)\n    db.commit()\n    return {\"message\": \"Instructor deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_location","title":"<code>delete_location(room_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a location by its room ID from the database.</p> Input <p>room_id (int): The unique identifier of the location to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/locations/{room_id}\", tags=[\"Locations\"])\nasync def delete_location(room_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a location by its room ID from the database.\n\n    Input:\n        room_id (int): The unique identifier of the location to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the location is not found, raises a 404 error.\n    \"\"\"\n    location = db.query(LocationDB).filter(LocationDB.room_id == room_id).first()\n    if not location:\n        raise HTTPException(status_code=404, detail=\"Location not found\")\n    db.delete(location)\n    db.commit()\n    return {\"message\": \"Location deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_preferred","title":"<code>delete_preferred(student_id, course_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a student-course preference record from the database.</p> Input <p>student_id (int): The unique identifier of the student. course_id (int): The unique identifier of the course. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the preference is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/preferred/\", tags=[\"Preferences\"])\nasync def delete_preferred(student_id: int, course_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a student-course preference record from the database.\n\n    Input:\n        student_id (int): The unique identifier of the student.\n        course_id (int): The unique identifier of the course.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the preference is not found, raises a 404 error.\n    \"\"\"\n    preferred = db.query(PreferredDB).filter(\n        PreferredDB.student_id == student_id,\n        PreferredDB.course_id == course_id\n    ).first()\n    if not preferred:\n        raise HTTPException(status_code=404, detail=\"Preference not found\")\n    db.delete(preferred)\n    db.commit()\n    return {\"message\": \"Preference deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_prerequisites","title":"<code>delete_prerequisites(course_id, prerequisite_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a prerequisite record from the database.</p> Input <p>course_id (int): The unique identifier of the course. prerequisite_id (int): The unique identifier of the prerequisite course. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the prerequisite is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/prerequisites/\", tags=[\"Prerequisites\"])\nasync def delete_prerequisites(course_id: int, prerequisite_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a prerequisite record from the database.\n\n    Input:\n        course_id (int): The unique identifier of the course.\n        prerequisite_id (int): The unique identifier of the prerequisite course.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the prerequisite is not found, raises a 404 error.\n    \"\"\"\n    prerequisites = db.query(PrerequisitesDB).filter(\n        PrerequisitesDB.course_id == course_id,\n        PrerequisitesDB.prerequisite_id == prerequisite_id\n    ).first()\n    if not prerequisites:\n        raise HTTPException(status_code=404, detail=\"Prerequisite not found\")\n    db.delete(prerequisites)\n    db.commit()\n    return {\"message\": \"Prerequisite deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_program","title":"<code>delete_program(prog_name, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a program by its name from the database.</p> Input <p>prog_name (str): The name of the program to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the program is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/programs/{prog_name}\", tags=[\"Programs\"])\nasync def delete_program(prog_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a program by its name from the database.\n\n    Input:\n        prog_name (str): The name of the program to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the program is not found, raises a 404 error.\n    \"\"\"\n    program = db.query(ProgramDB).filter(ProgramDB.prog_name == prog_name).first()\n    if not program:\n        raise HTTPException(status_code=404, detail=\"Program not found\")\n    db.delete(program)\n    db.commit()\n    return {\"message\": \"Program deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_recommendation_result","title":"<code>delete_recommendation_result(result_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a recommendation result by its unique ID from the database.</p> Input <p>result_id (int): The unique identifier of the recommendation result to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the recommendation result is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/recommendation-results/{result_id}\", tags=[\"Recommendations\"])\nasync def delete_recommendation_result(result_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a recommendation result by its unique ID from the database.\n\n    Input:\n        result_id (int): The unique identifier of the recommendation result to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the recommendation result is not found, raises a 404 error.\n    \"\"\"\n    result = db.query(RecommendationResultDB).filter(RecommendationResultDB.id == result_id).first()\n    if not result:\n        raise HTTPException(status_code=404, detail=\"Recommendation result not found\")\n    db.delete(result)\n    db.commit()\n    return {\"message\": \"Recommendation result deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_section","title":"<code>delete_section(section_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a section by its unique ID from the database.</p> Input <p>section_id (int): The unique identifier of the section to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the section is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/sections/{section_id}\", tags=[\"Sections\"])\nasync def delete_section(section_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a section by its unique ID from the database.\n\n    Input:\n        section_id (int): The unique identifier of the section to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the section is not found, raises a 404 error.\n    \"\"\"\n    try:\n        section = db.query(SectionDB).filter(SectionDB.id == section_id).first()\n        if not section:\n            raise HTTPException(status_code=404, detail=\"Section not found\")\n        db.delete(section)\n        db.commit()\n        return {\"message\": \"Section deleted successfully\"}\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Error deleting section: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.delete_student","title":"<code>delete_student(student_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a student by their unique ID from the database.</p> Input <p>student_id (int): The unique identifier of the student to delete. db (Session): Database session provided by dependency injection.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the student is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/students/{student_id}\", tags=[\"Students\"])\nasync def delete_student(student_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a student by their unique ID from the database.\n\n    Input:\n        student_id (int): The unique identifier of the student to delete.\n        db (Session): Database session provided by dependency injection.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the student is not found, raises a 404 error.\n    \"\"\"\n    try:\n        student = db.query(StudentDB).filter(StudentDB.student_id == student_id).first()\n        if not student:\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        db.delete(student)\n        db.commit()\n        return {\"message\": \"Student deleted successfully\"}\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Error deleting student: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.delete_takes","title":"<code>delete_takes(student_id, section_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a student enrollment record from the database.</p> Input <p>student_id (int): The unique identifier of the student. section_id (int): The unique identifier of the section. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the enrollment is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/takes/\", tags=[\"Enrollments\"])\nasync def delete_takes(student_id: int, section_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a student enrollment record from the database.\n\n    Input:\n        student_id (int): The unique identifier of the student.\n        section_id (int): The unique identifier of the section.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the enrollment is not found, raises a 404 error.\n    \"\"\"\n    takes = db.query(TakesDB).filter(\n        TakesDB.student_id == student_id,\n        TakesDB.section_id == section_id\n    ).first()\n    if not takes:\n        raise HTTPException(status_code=404, detail=\"Enrollment not found\")\n    db.delete(takes)\n    db.commit()\n    return {\"message\": \"Enrollment deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_timeslot","title":"<code>delete_timeslot(time_slot_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete a time slot by its unique ID from the database.</p> Input <p>time_slot_id (int): The unique identifier of the time slot to delete. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the time slot is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/timeslots/{time_slot_id}\", tags=[\"Time Slots\"])\nasync def delete_timeslot(time_slot_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete a time slot by its unique ID from the database.\n\n    Input:\n        time_slot_id (int): The unique identifier of the time slot to delete.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the time slot is not found, raises a 404 error.\n    \"\"\"\n    timeslot = db.query(TimeSlotDB).filter(TimeSlotDB.time_slot_id == time_slot_id).first()\n    if not timeslot:\n        raise HTTPException(status_code=404, detail=\"Time slot not found\")\n    db.delete(timeslot)\n    db.commit()\n    return {\"message\": \"Time slot deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.delete_works","title":"<code>delete_works(instructorid, dept_name, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Delete an instructor-department relationship record from the database.</p> Input <p>instructorid (int): The unique identifier of the instructor. dept_name (str): The name of the department. db (Session): Database session.</p> Output <p>dict: A message confirming successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the relationship is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.delete(\"/works/\", tags=[\"Works\"])\nasync def delete_works(instructorid: int, dept_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Delete an instructor-department relationship record from the database.\n\n    Input:\n        instructorid (int): The unique identifier of the instructor.\n        dept_name (str): The name of the department.\n        db (Session): Database session.\n\n    Output:\n        dict: A message confirming successful deletion.\n\n    Raises:\n        HTTPException: If the relationship is not found, raises a 404 error.\n    \"\"\"\n    works = db.query(WorksDB).filter(\n        WorksDB.instructorid == instructorid,\n        WorksDB.dept_name == dept_name\n    ).first()\n    if not works:\n        raise HTTPException(status_code=404, detail=\"Relationship not found\")\n    db.delete(works)\n    db.commit()\n    return {\"message\": \"Relationship deleted successfully\"}\n</code></pre>"},{"location":"api/#university_app.api.main.generate_recommendations","title":"<code>generate_recommendations(request, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Generate recommendations for a specific student with the given time preference. This will delete existing recommendations for the student and create new ones.</p> Input <p>student_id (int): The student ID to generate recommendations for time_preference (str): Time preference ('morning', 'afternoon', 'evening', 'any') semester (str): Semester ('Fall', 'Spring', 'Summer') year (int): Academic year</p> Output <p>dict: Success message and count of recommendations generated</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/recommendations/generate\", tags=[\"Recommendations\"])\nasync def generate_recommendations(\n    request: GenerateRecommendationRequest,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Generate recommendations for a specific student with the given time preference.\n    This will delete existing recommendations for the student and create new ones.\n\n    Input:\n        student_id (int): The student ID to generate recommendations for\n        time_preference (str): Time preference ('morning', 'afternoon', 'evening', 'any')\n        semester (str): Semester ('Fall', 'Spring', 'Summer')\n        year (int): Academic year\n\n    Output:\n        dict: Success message and count of recommendations generated\n    \"\"\"\n    if generate_recommendations_for_student is None:\n        raise HTTPException(\n            status_code=503,\n            detail=\"Recommendation service unavailable. Shared module not found. Please check Docker volumes.\"\n        )\n\n    try:\n        # Validate time preference\n        valid_preferences = ['morning', 'afternoon', 'evening', 'any']\n        if request.time_preference not in valid_preferences:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Invalid time_preference. Must be one of: {valid_preferences}\"\n            )\n\n        # Check if student exists\n        student = db.query(StudentDB).filter(StudentDB.student_id == request.student_id).first()\n        if not student:\n            raise HTTPException(status_code=404, detail=f\"Student with ID {request.student_id} not found\")\n\n        # Delete existing recommendations for this student\n        existing = db.query(RecommendationResultDB).filter(\n            RecommendationResultDB.student_id == request.student_id\n        ).all()\n        for rec in existing:\n            db.delete(rec)\n        db.commit()\n\n        # Generate new recommendations\n        print(f\"\ud83d\udd0d Generating recommendations for student {request.student_id} with time_preference: '{request.time_preference}'\")\n        recommendations = generate_recommendations_for_student(\n            engine=engine,\n            student_id=request.student_id,\n            time_preference=request.time_preference,\n            current_year=request.year,\n            current_semester=request.semester\n        )\n\n        print(f\"\ud83d\udcca Generated {len(recommendations) if recommendations else 0} recommendations\")\n        if recommendations:\n            # Log first few recommendations to see their section IDs\n            for i, rec in enumerate(recommendations[:3]):\n                print(f\"  Rec {i+1}: course_id={rec.get('course_id')}, section_id={rec.get('section_id')}, course_name={rec.get('course_name')}\")\n\n        if not recommendations:\n            return {\n                \"message\": f\"No recommendations generated for student {request.student_id}\",\n                \"count\": 0\n            }\n\n        # Save recommendations to database\n        saved_count = 0\n\n        for slot_num, rec in enumerate(recommendations, 1):\n            # Get time_slot_id from section\n            section_id = int(rec['section_id'])\n            section = db.query(SectionDB).filter(SectionDB.id == section_id).first()\n            time_slot_id = section.time_slot_id if section else None\n\n            # Convert why_recommended list to string\n            why_recommended_str = ', '.join(rec.get('why_recommended', []))\n\n            result_data = {\n                'student_id': request.student_id,\n                'course_id': int(rec['course_id']),\n                'recommended_section_id': int(rec['section_id']),\n                'course_name': rec['course_name'],\n                'cluster': rec.get('cluster', ''),\n                'credits': int(rec.get('credits', 0)),\n                'time_slot': int(time_slot_id) if time_slot_id is not None else None,\n                'recommendation_score': str(rec.get('score', '1.0')),\n                'why_recommended': why_recommended_str,\n                'slot_number': slot_num,\n                'model_version': 'semester_scheduler_v1',\n                'time_preference': request.time_preference,\n                'semester': request.semester,\n                'year': request.year\n            }\n\n            db_recommendation = RecommendationResultDB(**result_data)\n            db.add(db_recommendation)\n            saved_count += 1\n\n        db.commit()\n\n        return {\n            \"message\": f\"Successfully generated {saved_count} recommendations for student {request.student_id}\",\n            \"count\": saved_count,\n            \"time_preference\": request.time_preference\n        }\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Error generating recommendations: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.get_cluster","title":"<code>get_cluster(cluster_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a cluster by its unique ID.</p> Input <p>cluster_id (int): The unique identifier of the cluster. db (Session): Database session.</p> Output <p>Cluster: The cluster's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the cluster is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/clusters/{cluster_id}\", response_model=Cluster, tags=[\"Clusters\"])\nasync def get_cluster(cluster_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a cluster by its unique ID.\n\n    Input:\n        cluster_id (int): The unique identifier of the cluster.\n        db (Session): Database session.\n\n    Output:\n        Cluster: The cluster's details.\n\n    Raises:\n        HTTPException: If the cluster is not found, raises a 404 error.\n    \"\"\"\n    cluster = db.query(ClusterDB).filter(ClusterDB.cluster_id == cluster_id).first()\n    if cluster is None:\n        raise HTTPException(status_code=404, detail=\"Cluster not found\")\n    return cluster\n</code></pre>"},{"location":"api/#university_app.api.main.get_clusters","title":"<code>get_clusters(prog_name=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all clusters with optional filtering by program name.</p> Input <p>prog_name (Optional[str]): Filter by program name. db (Session): Database session.</p> Output <p>list[Cluster]: List of clusters.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/clusters\", response_model=list[Cluster], tags=[\"Clusters\"])\nasync def get_clusters(prog_name: Optional[str] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all clusters with optional filtering by program name.\n\n    Input:\n        prog_name (Optional[str]): Filter by program name.\n        db (Session): Database session.\n\n    Output:\n        list[Cluster]: List of clusters.\n    \"\"\"\n    query = db.query(ClusterDB)\n    if prog_name:\n        query = query.filter(ClusterDB.prog_name == prog_name)\n    clusters = query.all()\n    return clusters\n</code></pre>"},{"location":"api/#university_app.api.main.get_course","title":"<code>get_course(course_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a course by its unique ID.</p> Input <p>course_id (int): The unique identifier of the course. db (Session): Database session.</p> Output <p>Course: The course's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the course is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/courses/{course_id}\", response_model=Course, tags=[\"Courses\"])\nasync def get_course(course_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a course by its unique ID.\n\n    Input:\n        course_id (int): The unique identifier of the course.\n        db (Session): Database session.\n\n    Output:\n        Course: The course's details.\n\n    Raises:\n        HTTPException: If the course is not found, raises a 404 error.\n    \"\"\"\n    course = db.query(CourseDB).filter(CourseDB.id == course_id).first()\n    if course is None:\n        raise HTTPException(status_code=404, detail=\"Course not found\")\n    return course\n</code></pre>"},{"location":"api/#university_app.api.main.get_coursecluster","title":"<code>get_coursecluster(course_id=None, cluster_id=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all course-cluster relationships with optional filtering.</p> Input <p>course_id (Optional[int]): Filter by course ID. cluster_id (Optional[int]): Filter by cluster ID. db (Session): Database session.</p> Output <p>list[CourseCluster]: List of course-cluster relationships.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/coursecluster\", response_model=list[CourseCluster], tags=[\"Course Clusters\"])\nasync def get_coursecluster(course_id: Optional[int] = None, cluster_id: Optional[int] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all course-cluster relationships with optional filtering.\n\n    Input:\n        course_id (Optional[int]): Filter by course ID.\n        cluster_id (Optional[int]): Filter by cluster ID.\n        db (Session): Database session.\n\n    Output:\n        list[CourseCluster]: List of course-cluster relationships.\n    \"\"\"\n    query = db.query(CourseClusterDB)\n    if course_id:\n        query = query.filter(CourseClusterDB.course_id == course_id)\n    if cluster_id:\n        query = query.filter(CourseClusterDB.cluster_id == cluster_id)\n    courseclusters = query.all()\n    return courseclusters\n</code></pre>"},{"location":"api/#university_app.api.main.get_courses","title":"<code>get_courses(skip=0, limit=100, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all courses with pagination.</p> Input <p>skip (int): Number of records to skip, default 0. limit (int): Maximum number of records to return, default 100. db (Session): Database session.</p> Output <p>list[Course]: List of courses.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/courses\", response_model=list[Course], tags=[\"Courses\"])\nasync def get_courses(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all courses with pagination.\n\n    Input:\n        skip (int): Number of records to skip, default 0.\n        limit (int): Maximum number of records to return, default 100.\n        db (Session): Database session.\n\n    Output:\n        list[Course]: List of courses.\n    \"\"\"\n    courses = db.query(CourseDB).offset(skip).limit(limit).all()\n    return courses\n</code></pre>"},{"location":"api/#university_app.api.main.get_department","title":"<code>get_department(dept_name, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a department by its name.</p> Input <p>dept_name (str): The name of the department. db (Session): Database session.</p> Output <p>Department: The department's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the department is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/departments/{dept_name}\", response_model=Department, tags=[\"Departments\"])\nasync def get_department(dept_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a department by its name.\n\n    Input:\n        dept_name (str): The name of the department.\n        db (Session): Database session.\n\n    Output:\n        Department: The department's details.\n\n    Raises:\n        HTTPException: If the department is not found, raises a 404 error.\n    \"\"\"\n    department = db.query(DepartmentDB).filter(DepartmentDB.dept_name == dept_name).first()\n    if department is None:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    return department\n</code></pre>"},{"location":"api/#university_app.api.main.get_departments","title":"<code>get_departments(db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all departments.</p> Input <p>db (Session): Database session.</p> Output <p>list[Department]: List of departments.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/departments\", response_model=list[Department], tags=[\"Departments\"])\nasync def get_departments(db: Session = Depends(get_db)):\n    \"\"\"\n    Get all departments.\n\n    Input:\n        db (Session): Database session.\n\n    Output:\n        list[Department]: List of departments.\n    \"\"\"\n    departments = db.query(DepartmentDB).all()\n    return departments\n</code></pre>"},{"location":"api/#university_app.api.main.get_draft_schedule","title":"<code>get_draft_schedule(draft_schedule_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get a specific draft schedule by ID.</p> Input <p>draft_schedule_id (int): The ID of the draft schedule. db (Session): Database session.</p> Output <p>DraftSchedule: The draft schedule with its section IDs.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the draft schedule is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/draft-schedules/{draft_schedule_id}\", response_model=DraftSchedule, tags=[\"Draft Schedules\"])\nasync def get_draft_schedule(\n    draft_schedule_id: int,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Get a specific draft schedule by ID.\n\n    Input:\n        draft_schedule_id (int): The ID of the draft schedule.\n        db (Session): Database session.\n\n    Output:\n        DraftSchedule: The draft schedule with its section IDs.\n\n    Raises:\n        HTTPException: If the draft schedule is not found, raises a 404 error.\n    \"\"\"\n    schedule = db.query(DraftScheduleDB).filter(\n        DraftScheduleDB.draft_schedule_id == draft_schedule_id\n    ).first()\n\n    if schedule is None:\n        raise HTTPException(status_code=404, detail=\"Draft schedule not found\")\n\n    # Get section IDs for this schedule\n    section_ids = db.query(DraftScheduleSectionDB.section_id).filter(\n        DraftScheduleSectionDB.draft_schedule_id == schedule.draft_schedule_id\n    ).all()\n    section_id_list = [sid[0] for sid in section_ids]\n\n    return {\n        \"draft_schedule_id\": schedule.draft_schedule_id,\n        \"student_id\": schedule.student_id,\n        \"name\": schedule.name,\n        \"created_at\": schedule.created_at.isoformat() if schedule.created_at else \"\",\n        \"updated_at\": schedule.updated_at.isoformat() if schedule.updated_at else None,\n        \"section_ids\": section_id_list\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.get_draft_schedules","title":"<code>get_draft_schedules(student_id=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all draft schedules, optionally filtered by student_id.</p> Input <p>student_id (Optional[int]): Filter by student ID. If not provided, returns all schedules. db (Session): Database session.</p> Output <p>list[DraftSchedule]: List of draft schedules with their section IDs.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/draft-schedules\", response_model=list[DraftSchedule], tags=[\"Draft Schedules\"])\nasync def get_draft_schedules(\n    student_id: Optional[int] = None,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Get all draft schedules, optionally filtered by student_id.\n\n    Input:\n        student_id (Optional[int]): Filter by student ID. If not provided, returns all schedules.\n        db (Session): Database session.\n\n    Output:\n        list[DraftSchedule]: List of draft schedules with their section IDs.\n    \"\"\"\n    query = db.query(DraftScheduleDB)\n\n    if student_id is not None:\n        query = query.filter(DraftScheduleDB.student_id == student_id)\n\n    schedules = query.order_by(DraftScheduleDB.created_at.desc()).all()\n\n    result = []\n    for schedule in schedules:\n        # Get section IDs for this schedule\n        section_ids = db.query(DraftScheduleSectionDB.section_id).filter(\n            DraftScheduleSectionDB.draft_schedule_id == schedule.draft_schedule_id\n        ).all()\n        section_id_list = [sid[0] for sid in section_ids]\n\n        result.append({\n            \"draft_schedule_id\": schedule.draft_schedule_id,\n            \"student_id\": schedule.student_id,\n            \"name\": schedule.name,\n            \"created_at\": schedule.created_at.isoformat() if schedule.created_at else \"\",\n            \"updated_at\": schedule.updated_at.isoformat() if schedule.updated_at else None,\n            \"section_ids\": section_id_list\n        })\n\n    return result\n</code></pre>"},{"location":"api/#university_app.api.main.get_hascourse","title":"<code>get_hascourse(prog_name=None, courseid=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all program-course relationships with optional filtering.</p> Input <p>prog_name (Optional[str]): Filter by program name. courseid (Optional[int]): Filter by course ID. db (Session): Database session.</p> Output <p>list[HasCourse]: List of program-course relationships.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/hascourse\", response_model=list[HasCourse], tags=[\"Program Courses\"])\nasync def get_hascourse(prog_name: Optional[str] = None, courseid: Optional[int] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all program-course relationships with optional filtering.\n\n    Input:\n        prog_name (Optional[str]): Filter by program name.\n        courseid (Optional[int]): Filter by course ID.\n        db (Session): Database session.\n\n    Output:\n        list[HasCourse]: List of program-course relationships.\n    \"\"\"\n    query = db.query(HasCourseDB)\n    if prog_name:\n        query = query.filter(HasCourseDB.prog_name == prog_name)\n    if courseid:\n        query = query.filter(HasCourseDB.courseid == courseid)\n    hascourse = query.all()\n    return hascourse\n</code></pre>"},{"location":"api/#university_app.api.main.get_instructor","title":"<code>get_instructor(instructor_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve an instructor by their unique ID.</p> Input <p>instructor_id (int): The unique identifier of the instructor. db (Session): Database session.</p> Output <p>Instructor: The instructor's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instructor is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/instructors/{instructor_id}\", response_model=Instructor, tags=[\"Instructors\"])\nasync def get_instructor(instructor_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve an instructor by their unique ID.\n\n    Input:\n        instructor_id (int): The unique identifier of the instructor.\n        db (Session): Database session.\n\n    Output:\n        Instructor: The instructor's details.\n\n    Raises:\n        HTTPException: If the instructor is not found, raises a 404 error.\n    \"\"\"\n    instructor = db.query(InstructorDB).filter(InstructorDB.id == instructor_id).first()\n    if instructor is None:\n        raise HTTPException(status_code=404, detail=\"Instructor not found\")\n    return instructor\n</code></pre>"},{"location":"api/#university_app.api.main.get_instructors","title":"<code>get_instructors(skip=0, limit=100, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all instructors with pagination.</p> Input <p>skip (int): Number of records to skip, default 0. limit (int): Maximum number of records to return, default 100. db (Session): Database session.</p> Output <p>list[Instructor]: List of instructors.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/instructors\", response_model=list[Instructor], tags=[\"Instructors\"])\nasync def get_instructors(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all instructors with pagination.\n\n    Input:\n        skip (int): Number of records to skip, default 0.\n        limit (int): Maximum number of records to return, default 100.\n        db (Session): Database session.\n\n    Output:\n        list[Instructor]: List of instructors.\n    \"\"\"\n    instructors = db.query(InstructorDB).offset(skip).limit(limit).all()\n    return instructors\n</code></pre>"},{"location":"api/#university_app.api.main.get_location","title":"<code>get_location(room_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a location by its room ID.</p> Input <p>room_id (int): The unique identifier of the location. db (Session): Database session.</p> Output <p>Location: The location's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/locations/{room_id}\", response_model=Location, tags=[\"Locations\"])\nasync def get_location(room_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a location by its room ID.\n\n    Input:\n        room_id (int): The unique identifier of the location.\n        db (Session): Database session.\n\n    Output:\n        Location: The location's details.\n\n    Raises:\n        HTTPException: If the location is not found, raises a 404 error.\n    \"\"\"\n    location = db.query(LocationDB).filter(LocationDB.room_id == room_id).first()\n    if location is None:\n        raise HTTPException(status_code=404, detail=\"Location not found\")\n    return location\n</code></pre>"},{"location":"api/#university_app.api.main.get_locations","title":"<code>get_locations(skip=0, limit=100, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all locations with pagination.</p> Input <p>skip (int): Number of records to skip, default 0. limit (int): Maximum number of records to return, default 100. db (Session): Database session.</p> Output <p>list[Location]: List of locations.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/locations\", response_model=list[Location], tags=[\"Locations\"])\nasync def get_locations(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all locations with pagination.\n\n    Input:\n        skip (int): Number of records to skip, default 0.\n        limit (int): Maximum number of records to return, default 100.\n        db (Session): Database session.\n\n    Output:\n        list[Location]: List of locations.\n    \"\"\"\n    locations = db.query(LocationDB).offset(skip).limit(limit).all()\n    return locations\n</code></pre>"},{"location":"api/#university_app.api.main.get_preferred","title":"<code>get_preferred(student_id=None, course_id=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all student-course preferences with optional filtering.</p> Input <p>student_id (Optional[int]): Filter by student ID. course_id (Optional[int]): Filter by course ID. db (Session): Database session.</p> Output <p>list[Preferred]: List of student-course preferences.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/preferred\", response_model=list[Preferred], tags=[\"Preferences\"])\nasync def get_preferred(student_id: Optional[int] = None, course_id: Optional[int] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all student-course preferences with optional filtering.\n\n    Input:\n        student_id (Optional[int]): Filter by student ID.\n        course_id (Optional[int]): Filter by course ID.\n        db (Session): Database session.\n\n    Output:\n        list[Preferred]: List of student-course preferences.\n    \"\"\"\n    query = db.query(PreferredDB)\n    if student_id:\n        query = query.filter(PreferredDB.student_id == student_id)\n    if course_id:\n        query = query.filter(PreferredDB.course_id == course_id)\n    preferred = query.all()\n    return preferred\n</code></pre>"},{"location":"api/#university_app.api.main.get_prerequisites","title":"<code>get_prerequisites(course_id=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all prerequisites with optional filtering by course ID.</p> Input <p>course_id (Optional[int]): Filter by course ID. db (Session): Database session.</p> Output <p>list[Prerequisites]: List of prerequisite records.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/prerequisites\", response_model=list[Prerequisites], tags=[\"Prerequisites\"])\nasync def get_prerequisites(course_id: Optional[int] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all prerequisites with optional filtering by course ID.\n\n    Input:\n        course_id (Optional[int]): Filter by course ID.\n        db (Session): Database session.\n\n    Output:\n        list[Prerequisites]: List of prerequisite records.\n    \"\"\"\n    query = db.query(PrerequisitesDB)\n    if course_id:\n        query = query.filter(PrerequisitesDB.course_id == course_id)\n    prerequisites = query.all()\n    return prerequisites\n</code></pre>"},{"location":"api/#university_app.api.main.get_program","title":"<code>get_program(prog_name, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a program by its name.</p> Input <p>prog_name (str): The name of the program. db (Session): Database session.</p> Output <p>Program: The program's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the program is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/programs/{prog_name}\", response_model=Program, tags=[\"Programs\"])\nasync def get_program(prog_name: str, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a program by its name.\n\n    Input:\n        prog_name (str): The name of the program.\n        db (Session): Database session.\n\n    Output:\n        Program: The program's details.\n\n    Raises:\n        HTTPException: If the program is not found, raises a 404 error.\n    \"\"\"\n    program = db.query(ProgramDB).filter(ProgramDB.prog_name == prog_name).first()\n    if program is None:\n        raise HTTPException(status_code=404, detail=\"Program not found\")\n    return program\n</code></pre>"},{"location":"api/#university_app.api.main.get_programs","title":"<code>get_programs(db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all programs.</p> Input <p>db (Session): Database session.</p> Output <p>list[Program]: List of programs.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/programs\", response_model=list[Program], tags=[\"Programs\"])\nasync def get_programs(db: Session = Depends(get_db)):\n    \"\"\"\n    Get all programs.\n\n    Input:\n        db (Session): Database session.\n\n    Output:\n        list[Program]: List of programs.\n    \"\"\"\n    programs = db.query(ProgramDB).all()\n    return programs\n</code></pre>"},{"location":"api/#university_app.api.main.get_recommendation_result","title":"<code>get_recommendation_result(result_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a recommendation result by its unique ID.</p> Input <p>result_id (int): The unique identifier of the recommendation result. db (Session): Database session.</p> Output <p>RecommendationResult: The recommendation result's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the recommendation result is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/recommendation-results/{result_id}\", response_model=RecommendationResult, tags=[\"Recommendations\"])\nasync def get_recommendation_result(result_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a recommendation result by its unique ID.\n\n    Input:\n        result_id (int): The unique identifier of the recommendation result.\n        db (Session): Database session.\n\n    Output:\n        RecommendationResult: The recommendation result's details.\n\n    Raises:\n        HTTPException: If the recommendation result is not found, raises a 404 error.\n    \"\"\"\n    result = db.query(RecommendationResultDB).filter(RecommendationResultDB.id == result_id).first()\n    if result is None:\n        raise HTTPException(status_code=404, detail=\"Recommendation result not found\")\n\n    return {\n        \"id\": result.id,\n        \"student_id\": result.student_id,\n        \"course_id\": result.course_id,\n        \"recommended_section_id\": result.recommended_section_id,\n        \"course_name\": result.course_name,\n        \"cluster\": result.cluster,\n        \"credits\": result.credits,\n        \"time_slot\": result.time_slot,\n        \"recommendation_score\": result.recommendation_score,\n        \"why_recommended\": result.why_recommended,\n        \"slot_number\": result.slot_number,\n        \"model_version\": result.model_version,\n        \"time_preference\": result.time_preference,\n        \"semester\": result.semester,\n        \"year\": result.year,\n        \"created_at\": result.created_at.isoformat() if result.created_at else \"\",\n        \"updated_at\": result.updated_at.isoformat() if result.updated_at else None\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.get_recommendation_results","title":"<code>get_recommendation_results(student_id=None, semester=None, year=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all recommendation results with optional filtering by student, semester, and year.</p> Input <p>student_id (Optional[int]): Filter by student ID. semester (Optional[str]): Filter by semester (e.g., 'Fall', 'Spring', 'Summer'). year (Optional[int]): Filter by year. db (Session): Database session.</p> Output <p>list[RecommendationResult]: List of recommendation results.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/recommendation-results\", response_model=list[RecommendationResult], tags=[\"Recommendations\"])\nasync def get_recommendation_results(\n    student_id: Optional[int] = None,\n    semester: Optional[str] = None,\n    year: Optional[int] = None,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Get all recommendation results with optional filtering by student, semester, and year.\n\n    Input:\n        student_id (Optional[int]): Filter by student ID.\n        semester (Optional[str]): Filter by semester (e.g., 'Fall', 'Spring', 'Summer').\n        year (Optional[int]): Filter by year.\n        db (Session): Database session.\n\n    Output:\n        list[RecommendationResult]: List of recommendation results.\n    \"\"\"\n    query = db.query(RecommendationResultDB)\n    if student_id:\n        query = query.filter(RecommendationResultDB.student_id == student_id)\n    if semester:\n        query = query.filter(RecommendationResultDB.semester == semester)\n    if year:\n        query = query.filter(RecommendationResultDB.year == year)\n    results = query.order_by(RecommendationResultDB.created_at.desc()).all()\n\n    # Format response with ISO timestamps\n    formatted_results = []\n    for result in results:\n        result_dict = {\n            \"id\": result.id,\n            \"student_id\": result.student_id,\n            \"course_id\": result.course_id,\n            \"recommended_section_id\": result.recommended_section_id,\n            \"course_name\": result.course_name,\n            \"cluster\": result.cluster,\n            \"credits\": result.credits,\n            \"time_slot\": result.time_slot,\n            \"recommendation_score\": result.recommendation_score,\n            \"why_recommended\": result.why_recommended,\n            \"slot_number\": result.slot_number,\n            \"model_version\": result.model_version,\n            \"time_preference\": result.time_preference,\n            \"semester\": result.semester,\n            \"year\": result.year,\n            \"created_at\": result.created_at.isoformat() if result.created_at else \"\",\n            \"updated_at\": result.updated_at.isoformat() if result.updated_at else None\n        }\n        formatted_results.append(result_dict)\n    return formatted_results\n</code></pre>"},{"location":"api/#university_app.api.main.get_section","title":"<code>get_section(section_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a section by its unique ID.</p> Input <p>section_id (int): The unique identifier of the section. db (Session): Database session.</p> Output <p>Section: The section's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the section is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/sections/{section_id}\", response_model=Section, tags=[\"Sections\"])\nasync def get_section(section_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a section by its unique ID.\n\n    Input:\n        section_id (int): The unique identifier of the section.\n        db (Session): Database session.\n\n    Output:\n        Section: The section's details.\n\n    Raises:\n        HTTPException: If the section is not found, raises a 404 error.\n    \"\"\"\n    section = db.query(SectionDB).filter(SectionDB.id == section_id).first()\n    if section is None:\n        raise HTTPException(status_code=404, detail=\"Section not found\")\n    return section\n</code></pre>"},{"location":"api/#university_app.api.main.get_sections","title":"<code>get_sections(year=None, semester=None, course_type=None, search=None, db=Depends(get_db))</code>  <code>async</code>","text":"Description <p>Get all sections with optional filtering by year, semester, course type, and search text. Returns sections with joined data from courses, instructors, time slots, and locations for frontend display.</p> Input <p>year (Optional[int]): Filter by year. semester (Optional[str]): Filter by semester (e.g., 'Fall', 'Spring', 'Summer'). course_type (Optional[str]): Filter by course type (GenEd, Major, Elective). search (Optional[str]): Search by course name. db (Session): Database session.</p> Output <p>list[dict]: List of sections with joined course, instructor, time slot, and location data.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/sections\", tags=[\"Sections\"])\nasync def get_sections(\n    year: Optional[str] = None,\n    semester: Optional[str] = None,\n    course_type: Optional[str] = None,\n    search: Optional[str] = None,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Description:\n        Get all sections with optional filtering by year, semester, course type, and search text.\n        Returns sections with joined data from courses, instructors, time slots, and locations for frontend display.\n\n    Input:\n        year (Optional[int]): Filter by year.\n        semester (Optional[str]): Filter by semester (e.g., 'Fall', 'Spring', 'Summer').\n        course_type (Optional[str]): Filter by course type (GenEd, Major, Elective).\n        search (Optional[str]): Search by course name.\n        db (Session): Database session.\n\n    Output:\n        list[dict]: List of sections with joined course, instructor, time slot, and location data.\n    \"\"\"\n    # Filter by course type if provided - course_type is now the program name directly\n    filtered_course_ids = None\n    if course_type and course_type != \"All\":\n        # Get course IDs that belong to this program\n        course_id_list = db.query(HasCourseDB.courseid).filter(\n            HasCourseDB.prog_name == course_type\n        ).distinct().all()\n        filtered_course_ids = [cid[0] for cid in course_id_list]\n\n    # Start with sections and join related tables\n    query = db.query(\n        SectionDB, CourseDB, InstructorDB, TimeSlotDB, LocationDB, SectionNameDB\n    ).join(\n        CourseDB, SectionDB.course_id == CourseDB.id\n    ).join(\n        InstructorDB, SectionDB.instructor_id == InstructorDB.id, isouter=True\n    ).join(\n        TimeSlotDB, SectionDB.time_slot_id == TimeSlotDB.time_slot_id, isouter=True\n    ).join(\n        LocationDB, SectionDB.roomID == LocationDB.room_id, isouter=True\n    ).join(\n        SectionNameDB, SectionDB.id == SectionNameDB.section_id, isouter=True\n    )\n\n    # Apply course type filter if provided\n    if filtered_course_ids is not None:\n        query = query.filter(CourseDB.id.in_(filtered_course_ids))\n\n    # Filter by year and semester\n    if year is not None:\n        try:\n            year_int = int(year)\n            query = query.filter(TimeSlotDB.year == year_int)\n        except (ValueError, TypeError):\n            pass  # Invalid year format, skip filter\n    if semester:\n        query = query.filter(TimeSlotDB.semester == semester)\n\n    # Filter by course name if search provided\n    if search:\n        query = query.filter(CourseDB.name.ilike(f\"%{search}%\"))\n\n    results = query.all()\n\n    # Helper function to expand MWF/TTh days\n    def expand_days(day_str):\n        \"\"\"Expand single day to MWF or TTh group if applicable\"\"\"\n        if not day_str:\n            return day_str\n\n        day_lower = day_str.strip().lower()\n        # MWF pattern: if any of Mon, Wed, Fri, return all three\n        if day_lower in ['mon', 'monday']:\n            return \"Monday, Wednesday, Friday\"\n        elif day_lower in ['wed', 'wednesday']:\n            return \"Monday, Wednesday, Friday\"\n        elif day_lower in ['fri', 'friday']:\n            return \"Monday, Wednesday, Friday\"\n        # TTh pattern: if any of Tue, Thu, return both\n        elif day_lower in ['tue', 'tuesday']:\n            return \"Tuesday, Thursday\"\n        elif day_lower in ['thu', 'thursday']:\n            return \"Tuesday, Thursday\"\n        # Otherwise return as-is (for other days like Sat, Sun)\n        return day_str\n\n    # Helper function to format time (remove seconds)\n    def format_time(time_str):\n        \"\"\"Format time from HH:MM:SS to HH:MM\"\"\"\n        if not time_str:\n            return \"\"\n        # Remove seconds if present\n        if len(time_str) &gt;= 8 and time_str.count(':') &gt;= 2:\n            return time_str[:5]  # Take HH:MM\n        return time_str\n\n    # Format response for frontend\n    formatted_sections = []\n    for section, course, instructor, timeslot, location, section_name in results:\n        # Get cluster numbers for this course by joining course_cluster with clusters table\n        cluster_numbers = db.query(ClusterDB.cluster_number).join(\n            CourseClusterDB, CourseClusterDB.cluster_id == ClusterDB.cluster_id\n        ).filter(\n            CourseClusterDB.course_id == course.id\n        ).all()\n        cluster_ids = [c[0] for c in cluster_numbers]  # cluster_ids now contains cluster_number values\n\n        # Get enrollment count (taken seats)\n        taken_seats = db.query(TakesDB).filter(\n            TakesDB.section_id == section.id,\n            TakesDB.status.in_(['enrolled', 'completed'])\n        ).count()\n\n        # Format time slot with day expansion and time formatting\n        days = expand_days(timeslot.day_of_week if timeslot else \"\")\n        start_time = format_time(timeslot.start_time) if timeslot and timeslot.start_time else \"\"\n        end_time = format_time(timeslot.end_time) if timeslot and timeslot.end_time else \"\"\n        time = f\"{start_time}-{end_time}\" if start_time and end_time else \"\"\n\n        # Extract course code from name (first word) or use course ID as fallback\n        course_code = str(course.id)\n        if course.name and course.name.strip():\n            name_parts = course.name.split()\n            if name_parts:\n                course_code = name_parts[0]\n\n        # Format semester and year (e.g., \"Fall 2023\")\n        semester_year = \"\"\n        if timeslot:\n            semester_name = timeslot.semester or \"\"\n            year_value = timeslot.year or \"\"\n            if semester_name and year_value:\n                semester_year = f\"{semester_name} {year_value}\"\n\n        # Get section letter (A, B, C, etc.) from section_name table\n        # If no section_name found, fallback to section ID\n        section_letter = section_name.section_name if section_name and section_name.section_name else str(section.id)\n\n        formatted_sections.append({\n            \"id\": str(section.id),\n            \"code\": course_code,\n            \"name\": course.name or \"\",\n            \"cluster\": cluster_ids,\n            \"section\": section_letter,\n            \"instructor\": instructor.name if instructor else \"\",\n            \"days\": days,\n            \"time\": time,\n            \"takenSeats\": taken_seats,\n            \"totalSeats\": section.capacity or 0,\n            \"location\": location.building_room_name if location else \"\",\n            \"duration\": section.duration or \"\",\n            \"syllabusUrl\": section.syllabus_url,\n            \"instructorBioUrl\": instructor.bio_url if instructor else None,\n            \"credits\": course.credits or 0,\n            \"semester\": timeslot.semester if timeslot else \"\",\n            \"year\": timeslot.year if timeslot else None,\n            \"semesterYear\": semester_year\n        })\n\n    return formatted_sections\n</code></pre>"},{"location":"api/#university_app.api.main.get_student","title":"<code>get_student(student_id, db=Depends(get_db))</code>  <code>async</code>","text":"Description <p>Retrieve a student by their unique ID.</p> Input <p>student_id (int): The unique identifier of the student. db (Session): Database session provided by dependency injection.</p> Output <p>Student: The student's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the student is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/students/{student_id}\", response_model=Student, tags=[\"Students\"])\nasync def get_student(student_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Description:\n        Retrieve a student by their unique ID.\n\n    Input:\n        student_id (int): The unique identifier of the student.\n        db (Session): Database session provided by dependency injection.\n\n    Output:\n        Student: The student's details.\n\n    Raises:\n        HTTPException: If the student is not found, raises a 404 error.\n    \"\"\"\n    student = db.query(StudentDB).filter(StudentDB.student_id == student_id).first()\n    if student is None:\n        raise HTTPException(status_code=404, detail=\"Student not found\")\n    return student\n</code></pre>"},{"location":"api/#university_app.api.main.get_student_statistics","title":"<code>get_student_statistics(student_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get comprehensive statistics for a student including: - GPA progress over time - Credits earned and remaining - Semester progress - Course completion by program - Grade distribution - Performance by course type - Time slot performance - Course load per semester - Prerequisites completion status</p> Input <p>student_id (int): The student ID to get statistics for. db (Session): Database session.</p> Output <p>StatisticsResponse: All statistics for the student.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If student not found or database error occurs.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/statistics/{student_id}\", response_model=StatisticsResponse, tags=[\"Statistics\"])\nasync def get_student_statistics(\n    student_id: int,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive statistics for a student including:\n    - GPA progress over time\n    - Credits earned and remaining\n    - Semester progress\n    - Course completion by program\n    - Grade distribution\n    - Performance by course type\n    - Time slot performance\n    - Course load per semester\n    - Prerequisites completion status\n\n    Input:\n        student_id (int): The student ID to get statistics for.\n        db (Session): Database session.\n\n    Output:\n        StatisticsResponse: All statistics for the student.\n\n    Raises:\n        HTTPException: If student not found or database error occurs.\n    \"\"\"\n    try:\n        # Input validation\n        if student_id &lt;= 0:\n            raise HTTPException(status_code=400, detail=\"Invalid student_id\")\n\n        # Verify student exists\n        student = db.query(StudentDB).filter(StudentDB.student_id == student_id).first()\n        if student is None:\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n\n        # Pre-load all data to avoid N+1 queries\n        # Load all takes with related data in one query\n        takes_query = db.query(\n            TakesDB,\n            SectionDB,\n            TimeSlotDB,\n            CourseDB\n        ).join(\n            SectionDB, TakesDB.section_id == SectionDB.id\n        ).join(\n            TimeSlotDB, SectionDB.time_slot_id == TimeSlotDB.time_slot_id\n        ).join(\n            CourseDB, SectionDB.course_id == CourseDB.id\n        ).filter(\n            TakesDB.student_id == student_id\n        )\n\n        # Pre-load course type mappings to avoid N+1 queries\n        all_has_courses = db.query(HasCourseDB).all()\n        course_type_map = {}\n        for has_course in all_has_courses:\n            if has_course.courseid not in course_type_map:\n                course_type_map[has_course.courseid] = []\n            course_type_map[has_course.courseid].append(has_course.prog_name)\n\n        # Load all takes data into memory once\n        all_takes_data = takes_query.all()\n\n        # 1. GPA Progress over time\n        gpa_data = []\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                gpa_value = GRADE_TO_GPA[takes.grade]\n                term = f\"{time_slot.year}-{time_slot.semester}\"\n                gpa_data.append({\n                    \"term\": term,\n                    \"year\": time_slot.year,\n                    \"semester\": time_slot.semester,\n                    \"gpa\": gpa_value\n                })\n\n        # Calculate average GPA per term\n        term_gpa = {}\n        for item in gpa_data:\n            term = item[\"term\"]\n            if term not in term_gpa:\n                term_gpa[term] = {\"gpas\": [], \"year\": item[\"year\"], \"semester\": item[\"semester\"]}\n            term_gpa[term][\"gpas\"].append(item[\"gpa\"])\n\n        gpa_progress = []\n        for term, data in sorted(term_gpa.items()):\n            avg_gpa = sum(data[\"gpas\"]) / len(data[\"gpas\"])\n            gpa_progress.append(GPAProgressPoint(\n                term=term,\n                year=data[\"year\"],\n                semester=data[\"semester\"],\n                gpa=round(avg_gpa, 2)\n            ))\n\n        # 2. Credits Progress\n        credit_earned = student.credit or 0\n        total_credits = 121  # Standard total credits\n        remaining = max(0, total_credits - credit_earned)\n\n        credits_progress = CreditsProgress(\n            credit_earned=credit_earned,\n            total_credits=total_credits,\n            remaining=remaining\n        )\n\n        # 3. Semester Progress\n        today = date.today()\n        # Assume Fall semester: Sept 1 to Dec 20\n        semester_start = date(today.year, 9, 1)\n        semester_end = date(today.year, 12, 20)\n\n        # If we're past December, use next year's dates\n        if today &gt; semester_end:\n            semester_start = date(today.year + 1, 9, 1)\n            semester_end = date(today.year + 1, 12, 20)\n\n        days_total = (semester_end - semester_start).days\n        days_passed = max(0, min(days_total, (today - semester_start).days))\n        percentage = round((days_passed / days_total * 100), 1) if days_total &gt; 0 else 0\n\n        semester_progress = SemesterProgress(\n            percentage=percentage,\n            days_passed=days_passed,\n            days_total=days_total\n        )\n\n        # 4. Course Completion by Program\n        # Get courses student has taken (with completed status) - use pre-loaded data\n        student_course_ids = set()\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.status == \"completed\":\n                student_course_ids.add(section.course_id)\n\n        # Get total courses per program - use pre-loaded map\n        program_stats = {}\n        for course_id, prog_names in course_type_map.items():\n            for prog_name in prog_names:\n                if prog_name not in program_stats:\n                    program_stats[prog_name] = {\"total\": set(), \"taken\": 0}\n                program_stats[prog_name][\"total\"].add(course_id)\n                if course_id in student_course_ids:\n                    program_stats[prog_name][\"taken\"] += 1\n\n        course_completion = []\n        for prog_name, stats in program_stats.items():\n            total = len(stats[\"total\"])\n            taken = stats[\"taken\"]\n            remaining = max(0, total - taken)\n\n            course_completion.append(CourseCompletionByProgram(\n                program=prog_name,\n                taken=taken,\n                remaining=remaining,\n                total=total\n            ))\n\n        # Sort by program name\n        course_completion.sort(key=lambda x: x.program)\n\n        # 5. Grade Distribution\n        grade_counts = {}\n        total_grades = 0\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                grade_counts[takes.grade] = grade_counts.get(takes.grade, 0) + 1\n                total_grades += 1\n\n        grade_distribution = []\n        for grade in [\"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\", \"C-\", \"D+\", \"D\", \"F\"]:\n            count = grade_counts.get(grade, 0)\n            percentage = (count / total_grades * 100) if total_grades &gt; 0 else 0\n            grade_distribution.append(GradeDistribution(\n                grade=grade,\n                count=count,\n                percentage=round(percentage, 1)\n            ))\n\n        # 6. Performance by Course Type\n        # Get course types from pre-loaded map\n        course_type_gpas = {\"GENED\": [], \"BSDS\": [], \"FND\": []}\n\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                gpa_value = GRADE_TO_GPA[takes.grade]\n                # Get course type from pre-loaded map\n                course_types = course_type_map.get(section.course_id, [])\n                for prog_name in course_types:\n                    if prog_name in course_type_gpas:\n                        course_type_gpas[prog_name].append(gpa_value)\n\n        performance_by_course_type = []\n        for course_type, gpas in course_type_gpas.items():\n            if gpas:\n                avg_gpa = sum(gpas) / len(gpas)\n                performance_by_course_type.append(PerformanceByCourseType(\n                    course_type=course_type,\n                    average_gpa=round(avg_gpa, 2),\n                    course_count=len(gpas)\n                ))\n\n        # 7. Credit Accumulation Over Time\n        # Get all completed courses with credits\n        credit_accumulation_data = {}\n        cumulative_credits = 0\n\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.status == \"completed\":\n                term = f\"{time_slot.year}-{time_slot.semester}\"\n                if term not in credit_accumulation_data:\n                    credit_accumulation_data[term] = {\n                        \"year\": time_slot.year,\n                        \"semester\": time_slot.semester,\n                        \"credits\": 0\n                    }\n                credit_accumulation_data[term][\"credits\"] += course.credits\n\n        credit_accumulation = []\n        for term in sorted(credit_accumulation_data.keys()):\n            data = credit_accumulation_data[term]\n            cumulative_credits += data[\"credits\"]\n            credit_accumulation.append(CreditAccumulation(\n                term=term,\n                year=data[\"year\"],\n                semester=data[\"semester\"],\n                credits_earned=data[\"credits\"],\n                cumulative_credits=cumulative_credits\n            ))\n\n        # 8. Time Slot Performance\n        def get_time_slot_category(start_time: str) -&gt; str:\n            \"\"\"Categorize time slot as morning, afternoon, or evening\"\"\"\n            if not start_time:\n                return \"unknown\"\n            try:\n                # Parse time (format: \"HH:MM\" or \"HH:MM:SS\")\n                hour = int(start_time.split(\":\")[0])\n                if hour &lt; 12:\n                    return \"morning\"\n                elif hour &lt; 17:\n                    return \"afternoon\"\n                else:\n                    return \"evening\"\n            except (ValueError, IndexError):\n                return \"unknown\"\n\n        time_slot_performance = {\"morning\": [], \"afternoon\": [], \"evening\": []}\n\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                gpa_value = GRADE_TO_GPA[takes.grade]\n                time_category = get_time_slot_category(time_slot.start_time)\n                if time_category in time_slot_performance:\n                    time_slot_performance[time_category].append(gpa_value)\n\n        time_slot_perf_list = []\n        for time_slot, gpas in time_slot_performance.items():\n            if gpas:\n                avg_gpa = sum(gpas) / len(gpas)\n                time_slot_perf_list.append(TimeSlotPerformance(\n                    time_slot=time_slot,\n                    average_gpa=round(avg_gpa, 2),\n                    course_count=len(gpas)\n                ))\n\n        # 9. Course Load Per Semester\n        course_load_data = {}\n        for takes, section, time_slot, course in all_takes_data:\n            term = f\"{time_slot.year}-{time_slot.semester}\"\n            if term not in course_load_data:\n                course_load_data[term] = {\n                    \"year\": time_slot.year,\n                    \"semester\": time_slot.semester,\n                    \"credits\": 0\n                }\n            course_load_data[term][\"credits\"] += course.credits\n\n        course_load = []\n        for term in sorted(course_load_data.keys()):\n            data = course_load_data[term]\n            course_load.append(CourseLoad(\n                term=term,\n                year=data[\"year\"],\n                semester=data[\"semester\"],\n                credits=data[\"credits\"]\n            ))\n\n        # 10. Grade Trends by Course Type\n        grade_trends = {}\n\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                gpa_value = GRADE_TO_GPA[takes.grade]\n                term = f\"{time_slot.year}-{time_slot.semester}\"\n                # Get course type from pre-loaded map\n                course_types = course_type_map.get(section.course_id, [])\n                for course_type in course_types:\n                    if course_type in [\"GENED\", \"BSDS\", \"FND\"]:\n                        key = f\"{term}-{course_type}\"\n                        if key not in grade_trends:\n                            grade_trends[key] = {\n                                \"term\": term,\n                                \"year\": time_slot.year,\n                                \"semester\": time_slot.semester,\n                                \"course_type\": course_type,\n                                \"gpas\": []\n                            }\n                        grade_trends[key][\"gpas\"].append(gpa_value)\n\n        grade_trends_list = []\n        for key, data in sorted(grade_trends.items()):\n            avg_gpa = sum(data[\"gpas\"]) / len(data[\"gpas\"])\n            grade_trends_list.append(GradeTrendByCourseType(\n                term=data[\"term\"],\n                year=data[\"year\"],\n                semester=data[\"semester\"],\n                course_type=data[\"course_type\"],\n                gpa=round(avg_gpa, 2)\n            ))\n\n        # 11. Prerequisites Completion Status\n        # Get all courses student hasn't taken yet\n        all_courses = db.query(CourseDB).all()\n        # student_course_ids already computed above\n\n        prerequisites_status = []\n        for course in all_courses:\n            if course.id not in student_course_ids:\n                # Get prerequisites for this course\n                prereqs = db.query(PrerequisitesDB).filter(\n                    PrerequisitesDB.course_id == course.id\n                ).all()\n\n                if prereqs:\n                    total_prereqs = len(prereqs)\n                    completed_prereqs = sum(1 for prereq in prereqs if prereq.prerequisite_id in student_course_ids)\n                    completion_pct = (completed_prereqs / total_prereqs * 100) if total_prereqs &gt; 0 else 0\n\n                    prerequisites_status.append(PrerequisiteStatus(\n                        course_id=course.id,\n                        course_name=course.name,\n                        prerequisites_completed=completed_prereqs,\n                        prerequisites_total=total_prereqs,\n                        completion_percentage=round(completion_pct, 1)\n                    ))\n\n        # Sort by completion percentage (highest first)\n        prerequisites_status.sort(key=lambda x: x.completion_percentage, reverse=True)\n        # Limit to top 20 to avoid overwhelming the UI\n        prerequisites_status = prerequisites_status[:20]\n\n        # 12. Course Difficulty vs Performance\n        course_difficulty = []\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                course_difficulty.append(CourseDifficultyPerformance(\n                    course_id=course.id,\n                    course_name=course.name,\n                    credits=course.credits,\n                    grade=takes.grade,\n                    gpa_value=GRADE_TO_GPA[takes.grade]\n                ))\n\n        # 13. Semester Performance Heatmap\n        heatmap_data = {}\n        days_of_week = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n\n        for takes, section, time_slot, course in all_takes_data:\n            if takes.grade and takes.grade in GRADE_TO_GPA:\n                gpa_value = GRADE_TO_GPA[takes.grade]\n                day = time_slot.day_of_week\n                # Map day abbreviations to full names\n                day_map = {\"Mon\": \"Monday\", \"Tue\": \"Tuesday\", \"Wed\": \"Wednesday\", \n                          \"Thu\": \"Thursday\", \"Fri\": \"Friday\", \"Sat\": \"Saturday\", \"Sun\": \"Sunday\"}\n                day_full = day_map.get(day, day)\n                time_category = get_time_slot_category(time_slot.start_time)\n\n                key = f\"{day_full}-{time_category}\"\n                if key not in heatmap_data:\n                    heatmap_data[key] = {\n                        \"day_of_week\": day_full,\n                        \"time_slot\": time_category,\n                        \"gpas\": [],\n                        \"count\": 0\n                    }\n                heatmap_data[key][\"gpas\"].append(gpa_value)\n                heatmap_data[key][\"count\"] += 1\n\n        semester_heatmap = []\n        for key, data in heatmap_data.items():\n            if data[\"gpas\"]:\n                avg_gpa = sum(data[\"gpas\"]) / len(data[\"gpas\"])\n                semester_heatmap.append(SemesterPerformanceHeatmap(\n                    day_of_week=data[\"day_of_week\"],\n                    time_slot=data[\"time_slot\"],\n                    average_gpa=round(avg_gpa, 2),\n                    course_count=data[\"count\"]\n                ))\n\n        return StatisticsResponse(\n            gpa_progress=gpa_progress,\n            credits_progress=credits_progress,\n            semester_progress=semester_progress,\n            course_completion=course_completion,\n            grade_distribution=grade_distribution,\n            performance_by_course_type=performance_by_course_type,\n            credit_accumulation=credit_accumulation,\n            time_slot_performance=time_slot_perf_list,\n            course_load=course_load,\n            grade_trends_by_course_type=grade_trends_list,\n            prerequisites_status=prerequisites_status,\n            course_difficulty_performance=course_difficulty,\n            semester_performance_heatmap=semester_heatmap\n        )\n    except HTTPException:\n        raise\n    except Exception as e:\n        # Log the error and return 500\n        import traceback\n        print(f\"Error in get_student_statistics: {str(e)}\")\n        print(traceback.format_exc())\n        db.rollback()\n        raise HTTPException(\n            status_code=500,\n            detail=f\"Internal server error while calculating statistics: {str(e)}\"\n        )\n</code></pre>"},{"location":"api/#university_app.api.main.get_takes","title":"<code>get_takes(student_id=None, section_id=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all student enrollments (takes) with optional filtering.</p> Input <p>student_id (Optional[int]): Filter by student ID. section_id (Optional[int]): Filter by section ID. db (Session): Database session.</p> Output <p>list[Takes]: List of enrollment records.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/takes\", response_model=list[Takes], tags=[\"Enrollments\"])\nasync def get_takes(student_id: Optional[int] = None, section_id: Optional[int] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all student enrollments (takes) with optional filtering.\n\n    Input:\n        student_id (Optional[int]): Filter by student ID.\n        section_id (Optional[int]): Filter by section ID.\n        db (Session): Database session.\n\n    Output:\n        list[Takes]: List of enrollment records.\n    \"\"\"\n    query = db.query(TakesDB)\n    if student_id:\n        query = query.filter(TakesDB.student_id == student_id)\n    if section_id:\n        query = query.filter(TakesDB.section_id == section_id)\n    takes = query.all()\n    return takes\n</code></pre>"},{"location":"api/#university_app.api.main.get_timeslot","title":"<code>get_timeslot(time_slot_id, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Retrieve a time slot by its unique ID.</p> Input <p>time_slot_id (int): The unique identifier of the time slot. db (Session): Database session.</p> Output <p>TimeSlot: The time slot's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the time slot is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/timeslots/{time_slot_id}\", response_model=TimeSlot, tags=[\"Time Slots\"])\nasync def get_timeslot(time_slot_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Retrieve a time slot by its unique ID.\n\n    Input:\n        time_slot_id (int): The unique identifier of the time slot.\n        db (Session): Database session.\n\n    Output:\n        TimeSlot: The time slot's details.\n\n    Raises:\n        HTTPException: If the time slot is not found, raises a 404 error.\n    \"\"\"\n    timeslot = db.query(TimeSlotDB).filter(TimeSlotDB.time_slot_id == time_slot_id).first()\n    if timeslot is None:\n        raise HTTPException(status_code=404, detail=\"Time slot not found\")\n    return timeslot\n</code></pre>"},{"location":"api/#university_app.api.main.get_timeslots","title":"<code>get_timeslots(skip=0, limit=100, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all time slots with pagination.</p> Input <p>skip (int): Number of records to skip, default 0. limit (int): Maximum number of records to return, default 100. db (Session): Database session.</p> Output <p>list[TimeSlot]: List of time slots.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/timeslots\", response_model=list[TimeSlot], tags=[\"Time Slots\"])\nasync def get_timeslots(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all time slots with pagination.\n\n    Input:\n        skip (int): Number of records to skip, default 0.\n        limit (int): Maximum number of records to return, default 100.\n        db (Session): Database session.\n\n    Output:\n        list[TimeSlot]: List of time slots.\n    \"\"\"\n    timeslots = db.query(TimeSlotDB).offset(skip).limit(limit).all()\n    return timeslots\n</code></pre>"},{"location":"api/#university_app.api.main.get_works","title":"<code>get_works(instructorid=None, dept_name=None, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Get all instructor-department relationships with optional filtering.</p> Input <p>instructorid (Optional[int]): Filter by instructor ID. dept_name (Optional[str]): Filter by department name. db (Session): Database session.</p> Output <p>list[Works]: List of instructor-department relationships.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/works\", response_model=list[Works], tags=[\"Works\"])\nasync def get_works(instructorid: Optional[int] = None, dept_name: Optional[str] = None, db: Session = Depends(get_db)):\n    \"\"\"\n    Get all instructor-department relationships with optional filtering.\n\n    Input:\n        instructorid (Optional[int]): Filter by instructor ID.\n        dept_name (Optional[str]): Filter by department name.\n        db (Session): Database session.\n\n    Output:\n        list[Works]: List of instructor-department relationships.\n    \"\"\"\n    query = db.query(WorksDB)\n    if instructorid:\n        query = query.filter(WorksDB.instructorid == instructorid)\n    if dept_name:\n        query = query.filter(WorksDB.dept_name == dept_name)\n    works = query.all()\n    return works\n</code></pre>"},{"location":"api/#university_app.api.main.health_check","title":"<code>health_check(db=Depends(get_db))</code>  <code>async</code>","text":"Description <p>Health check endpoint for monitoring and load balancers. Checks API and database connectivity.</p> Input <p>None (uses database dependency)</p> Output <p>dict: Health status with API and database status</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.get(\"/health\", tags=[\"Health\"])\nasync def health_check(db: Session = Depends(get_db)):\n    \"\"\"\n    Description:\n        Health check endpoint for monitoring and load balancers.\n        Checks API and database connectivity.\n\n    Input:\n        None (uses database dependency)\n\n    Output:\n        dict: Health status with API and database status\n    \"\"\"\n    try:\n        # Test database connection\n        db.execute(text(\"SELECT 1\"))\n        db_status = \"connected\"\n    except SQLAlchemyError:\n        db_status = \"disconnected\"\n\n    return {\n        \"status\": \"healthy\" if db_status == \"connected\" else \"unhealthy\",\n        \"api\": \"operational\",\n        \"database\": db_status\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.login","title":"<code>login(credentials, db=Depends(get_db))</code>  <code>async</code>","text":"Description <p>Authenticate a user with username and password.</p> Input <p>credentials (LoginRequest): Username and password db (Session): Database session</p> Output <p>dict: User information including user_id, username, student_id, and student info</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If credentials are invalid</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.post(\"/auth/login\", response_model=dict, tags=[\"Authentication\"])\nasync def login(credentials: LoginRequest, db: Session = Depends(get_db)):\n    \"\"\"\n    Description:\n        Authenticate a user with username and password.\n\n    Input:\n        credentials (LoginRequest): Username and password\n        db (Session): Database session\n\n    Output:\n        dict: User information including user_id, username, student_id, and student info\n\n    Raises:\n        HTTPException: If credentials are invalid\n    \"\"\"\n    user = db.query(UserDB).filter(UserDB.username == credentials.username).first()\n\n    if not user or user.password != credentials.password:\n        raise HTTPException(status_code=401, detail=\"Invalid username or password\")\n\n    # Get student information if linked\n    student = None\n    if user.student_id:\n        student = db.query(StudentDB).filter(StudentDB.student_id == user.student_id).first()\n\n    return {\n        \"user_id\": user.user_id,\n        \"username\": user.username,\n        \"student_id\": user.student_id,\n        \"student\": {\n            \"student_id\": student.student_id,\n            \"student_name\": student.student_name,\n            \"credit\": student.credit,\n            \"program_name\": student.program_name\n        } if student else None\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.startup_event","title":"<code>startup_event()</code>  <code>async</code>","text":"Description <p>Initialize database on startup. Creates tables and loads data if database is empty.</p> Input <p>None</p> Output <p>None</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"\n    Description:\n        Initialize database on startup. Creates tables and loads data if database is empty.\n\n    Input:\n        None\n\n    Output:\n        None\n    \"\"\"\n    ensure_database_initialized()\n</code></pre>"},{"location":"api/#university_app.api.main.update_cluster","title":"<code>update_cluster(cluster_id, updated_cluster, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing cluster's details in the database.</p> Input <p>cluster_id (int): The unique identifier of the cluster to update. updated_cluster (ClusterCreate): The new cluster data. db (Session): Database session.</p> Output <p>Cluster: The updated cluster's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the cluster is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/clusters/{cluster_id}\", response_model=Cluster, tags=[\"Clusters\"])\nasync def update_cluster(cluster_id: int, updated_cluster: ClusterCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing cluster's details in the database.\n\n    Input:\n        cluster_id (int): The unique identifier of the cluster to update.\n        updated_cluster (ClusterCreate): The new cluster data.\n        db (Session): Database session.\n\n    Output:\n        Cluster: The updated cluster's details.\n\n    Raises:\n        HTTPException: If the cluster is not found, raises a 404 error.\n    \"\"\"\n    cluster = db.query(ClusterDB).filter(ClusterDB.cluster_id == cluster_id).first()\n    if not cluster:\n        raise HTTPException(status_code=404, detail=\"Cluster not found\")\n    for key, value in updated_cluster.model_dump().items():\n        setattr(cluster, key, value)\n    db.commit()\n    db.refresh(cluster)\n    return cluster\n</code></pre>"},{"location":"api/#university_app.api.main.update_course","title":"<code>update_course(course_id, updated_course, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing course's details in the database.</p> Input <p>course_id (int): The unique identifier of the course to update. updated_course (CourseCreate): The new course data. db (Session): Database session.</p> Output <p>Course: The updated course's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the course is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/courses/{course_id}\", response_model=Course, tags=[\"Courses\"])\nasync def update_course(course_id: int, updated_course: CourseCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing course's details in the database.\n\n    Input:\n        course_id (int): The unique identifier of the course to update.\n        updated_course (CourseCreate): The new course data.\n        db (Session): Database session.\n\n    Output:\n        Course: The updated course's details.\n\n    Raises:\n        HTTPException: If the course is not found, raises a 404 error.\n    \"\"\"\n    course = db.query(CourseDB).filter(CourseDB.id == course_id).first()\n    if not course:\n        raise HTTPException(status_code=404, detail=\"Course not found\")\n    for key, value in updated_course.model_dump().items():\n        setattr(course, key, value)\n    db.commit()\n    db.refresh(course)\n    return course\n</code></pre>"},{"location":"api/#university_app.api.main.update_department","title":"<code>update_department(dept_name, updated_department, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing department's details in the database.</p> Input <p>dept_name (str): The name of the department to update. updated_department (DepartmentCreate): The new department data. db (Session): Database session.</p> Output <p>Department: The updated department's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the department is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/departments/{dept_name}\", response_model=Department, tags=[\"Departments\"])\nasync def update_department(dept_name: str, updated_department: DepartmentCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing department's details in the database.\n\n    Input:\n        dept_name (str): The name of the department to update.\n        updated_department (DepartmentCreate): The new department data.\n        db (Session): Database session.\n\n    Output:\n        Department: The updated department's details.\n\n    Raises:\n        HTTPException: If the department is not found, raises a 404 error.\n    \"\"\"\n    department = db.query(DepartmentDB).filter(DepartmentDB.dept_name == dept_name).first()\n    if not department:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    for key, value in updated_department.model_dump().items():\n        setattr(department, key, value)\n    db.commit()\n    db.refresh(department)\n    return department\n</code></pre>"},{"location":"api/#university_app.api.main.update_draft_schedule","title":"<code>update_draft_schedule(draft_schedule_id, schedule_data, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing draft schedule.</p> Input <p>draft_schedule_id (int): The ID of the draft schedule to update. schedule_data (DraftScheduleUpdate): The updated schedule data. db (Session): Database session.</p> Output <p>DraftSchedule: The updated draft schedule.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the draft schedule is not found or sections are invalid.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/draft-schedules/{draft_schedule_id}\", response_model=DraftSchedule, tags=[\"Draft Schedules\"])\nasync def update_draft_schedule(\n    draft_schedule_id: int,\n    schedule_data: DraftScheduleUpdate,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Update an existing draft schedule.\n\n    Input:\n        draft_schedule_id (int): The ID of the draft schedule to update.\n        schedule_data (DraftScheduleUpdate): The updated schedule data.\n        db (Session): Database session.\n\n    Output:\n        DraftSchedule: The updated draft schedule.\n\n    Raises:\n        HTTPException: If the draft schedule is not found or sections are invalid.\n    \"\"\"\n    schedule = db.query(DraftScheduleDB).filter(\n        DraftScheduleDB.draft_schedule_id == draft_schedule_id\n    ).first()\n\n    if schedule is None:\n        raise HTTPException(status_code=404, detail=\"Draft schedule not found\")\n\n    # Update name if provided\n    if schedule_data.name is not None:\n        schedule.name = schedule_data.name\n\n    # Update sections if provided\n    if schedule_data.section_ids is not None:\n        # Verify all sections exist\n        existing_sections = db.query(SectionDB.id).filter(\n            SectionDB.id.in_(schedule_data.section_ids)\n        ).all()\n        existing_section_ids = {sid[0] for sid in existing_sections}\n        invalid_sections = set(schedule_data.section_ids) - existing_section_ids\n        if invalid_sections:\n            raise HTTPException(\n                status_code=400,\n                detail=f\"Invalid section IDs: {list(invalid_sections)}\"\n            )\n\n        # Delete existing section associations\n        db.query(DraftScheduleSectionDB).filter(\n            DraftScheduleSectionDB.draft_schedule_id == draft_schedule_id\n        ).delete()\n\n        # Add new section associations\n        for section_id in schedule_data.section_ids:\n            schedule_section = DraftScheduleSectionDB(\n                draft_schedule_id=draft_schedule_id,\n                section_id=section_id\n            )\n            db.add(schedule_section)\n\n    db.commit()\n    db.refresh(schedule)\n\n    # Get updated section IDs\n    section_ids = db.query(DraftScheduleSectionDB.section_id).filter(\n        DraftScheduleSectionDB.draft_schedule_id == schedule.draft_schedule_id\n    ).all()\n    section_id_list = [sid[0] for sid in section_ids]\n\n    return {\n        \"draft_schedule_id\": schedule.draft_schedule_id,\n        \"student_id\": schedule.student_id,\n        \"name\": schedule.name,\n        \"created_at\": schedule.created_at.isoformat() if schedule.created_at else \"\",\n        \"updated_at\": schedule.updated_at.isoformat() if schedule.updated_at else None,\n        \"section_ids\": section_id_list\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.update_instructor","title":"<code>update_instructor(instructor_id, updated_instructor, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing instructor's details in the database.</p> Input <p>instructor_id (int): The unique identifier of the instructor to update. updated_instructor (InstructorCreate): The new instructor data. db (Session): Database session.</p> Output <p>Instructor: The updated instructor's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the instructor is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/instructors/{instructor_id}\", response_model=Instructor, tags=[\"Instructors\"])\nasync def update_instructor(instructor_id: int, updated_instructor: InstructorCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing instructor's details in the database.\n\n    Input:\n        instructor_id (int): The unique identifier of the instructor to update.\n        updated_instructor (InstructorCreate): The new instructor data.\n        db (Session): Database session.\n\n    Output:\n        Instructor: The updated instructor's details.\n\n    Raises:\n        HTTPException: If the instructor is not found, raises a 404 error.\n    \"\"\"\n    instructor = db.query(InstructorDB).filter(InstructorDB.id == instructor_id).first()\n    if not instructor:\n        raise HTTPException(status_code=404, detail=\"Instructor not found\")\n    for key, value in updated_instructor.model_dump().items():\n        setattr(instructor, key, value)\n    db.commit()\n    db.refresh(instructor)\n    return instructor\n</code></pre>"},{"location":"api/#university_app.api.main.update_location","title":"<code>update_location(room_id, updated_location, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing location's details in the database.</p> Input <p>room_id (int): The unique identifier of the location to update. updated_location (LocationCreate): The new location data. db (Session): Database session.</p> Output <p>Location: The updated location's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the location is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/locations/{room_id}\", response_model=Location, tags=[\"Locations\"])\nasync def update_location(room_id: int, updated_location: LocationCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing location's details in the database.\n\n    Input:\n        room_id (int): The unique identifier of the location to update.\n        updated_location (LocationCreate): The new location data.\n        db (Session): Database session.\n\n    Output:\n        Location: The updated location's details.\n\n    Raises:\n        HTTPException: If the location is not found, raises a 404 error.\n    \"\"\"\n    location = db.query(LocationDB).filter(LocationDB.room_id == room_id).first()\n    if not location:\n        raise HTTPException(status_code=404, detail=\"Location not found\")\n    for key, value in updated_location.model_dump().items():\n        setattr(location, key, value)\n    db.commit()\n    db.refresh(location)\n    return location\n</code></pre>"},{"location":"api/#university_app.api.main.update_program","title":"<code>update_program(prog_name, updated_program, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing program's details in the database.</p> Input <p>prog_name (str): The name of the program to update. updated_program (ProgramCreate): The new program data. db (Session): Database session.</p> Output <p>Program: The updated program's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the program is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/programs/{prog_name}\", response_model=Program, tags=[\"Programs\"])\nasync def update_program(prog_name: str, updated_program: ProgramCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing program's details in the database.\n\n    Input:\n        prog_name (str): The name of the program to update.\n        updated_program (ProgramCreate): The new program data.\n        db (Session): Database session.\n\n    Output:\n        Program: The updated program's details.\n\n    Raises:\n        HTTPException: If the program is not found, raises a 404 error.\n    \"\"\"\n    program = db.query(ProgramDB).filter(ProgramDB.prog_name == prog_name).first()\n    if not program:\n        raise HTTPException(status_code=404, detail=\"Program not found\")\n    for key, value in updated_program.model_dump().items():\n        setattr(program, key, value)\n    db.commit()\n    db.refresh(program)\n    return program\n</code></pre>"},{"location":"api/#university_app.api.main.update_recommendation_result","title":"<code>update_recommendation_result(result_id, updated_recommendation, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing recommendation result's details in the database.</p> Input <p>result_id (int): The unique identifier of the recommendation result to update. updated_recommendation (RecommendationResultCreate): The new recommendation result data. db (Session): Database session.</p> Output <p>RecommendationResult: The updated recommendation result's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the recommendation result is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/recommendation-results/{result_id}\", response_model=RecommendationResult, tags=[\"Recommendations\"])\nasync def update_recommendation_result(\n    result_id: int,\n    updated_recommendation: RecommendationResultCreate,\n    db: Session = Depends(get_db)\n):\n    \"\"\"\n    Update an existing recommendation result's details in the database.\n\n    Input:\n        result_id (int): The unique identifier of the recommendation result to update.\n        updated_recommendation (RecommendationResultCreate): The new recommendation result data.\n        db (Session): Database session.\n\n    Output:\n        RecommendationResult: The updated recommendation result's details.\n\n    Raises:\n        HTTPException: If the recommendation result is not found, raises a 404 error.\n    \"\"\"\n    result = db.query(RecommendationResultDB).filter(RecommendationResultDB.id == result_id).first()\n    if not result:\n        raise HTTPException(status_code=404, detail=\"Recommendation result not found\")\n\n    for key, value in updated_recommendation.model_dump().items():\n        setattr(result, key, value)\n    db.commit()\n    db.refresh(result)\n\n    return {\n        \"id\": result.id,\n        \"student_id\": result.student_id,\n        \"course_id\": result.course_id,\n        \"recommended_section_id\": result.recommended_section_id,\n        \"course_name\": result.course_name,\n        \"cluster\": result.cluster,\n        \"credits\": result.credits,\n        \"time_slot\": result.time_slot,\n        \"recommendation_score\": result.recommendation_score,\n        \"why_recommended\": result.why_recommended,\n        \"slot_number\": result.slot_number,\n        \"model_version\": result.model_version,\n        \"time_preference\": result.time_preference,\n        \"semester\": result.semester,\n        \"year\": result.year,\n        \"created_at\": result.created_at.isoformat() if result.created_at else \"\",\n        \"updated_at\": result.updated_at.isoformat() if result.updated_at else None\n    }\n</code></pre>"},{"location":"api/#university_app.api.main.update_section","title":"<code>update_section(section_id, updated_section, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing section's details in the database.</p> Input <p>section_id (int): The unique identifier of the section to update. updated_section (SectionCreate): The new section data. db (Session): Database session.</p> Output <p>Section: The updated section's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the section is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/sections/{section_id}\", response_model=Section, tags=[\"Sections\"])\nasync def update_section(section_id: int, updated_section: SectionCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing section's details in the database.\n\n    Input:\n        section_id (int): The unique identifier of the section to update.\n        updated_section (SectionCreate): The new section data.\n        db (Session): Database session.\n\n    Output:\n        Section: The updated section's details.\n\n    Raises:\n        HTTPException: If the section is not found, raises a 404 error.\n    \"\"\"\n    try:\n        section = db.query(SectionDB).filter(SectionDB.id == section_id).first()\n        if not section:\n            raise HTTPException(status_code=404, detail=\"Section not found\")\n        for key, value in updated_section.model_dump().items():\n            setattr(section, key, value)\n        db.commit()\n        db.refresh(section)\n        return section\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.update_student","title":"<code>update_student(student_id, updated_student, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing student's details in the database.</p> Input <p>student_id (int): The unique identifier of the student to update. updated_student (StudentCreate): The new student data. db (Session): Database session provided by dependency injection.</p> Output <p>Student: The updated student's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the student is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/students/{student_id}\", response_model=Student, tags=[\"Students\"])\nasync def update_student(student_id: int, updated_student: StudentCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing student's details in the database.\n\n    Input:\n        student_id (int): The unique identifier of the student to update.\n        updated_student (StudentCreate): The new student data.\n        db (Session): Database session provided by dependency injection.\n\n    Output:\n        Student: The updated student's details.\n\n    Raises:\n        HTTPException: If the student is not found, raises a 404 error.\n    \"\"\"\n    try:\n        student = db.query(StudentDB).filter(StudentDB.student_id == student_id).first()\n        if not student:\n            raise HTTPException(status_code=404, detail=\"Student not found\")\n        for key, value in updated_student.model_dump().items():\n            setattr(student, key, value)\n        db.commit()\n        db.refresh(student)\n        return student\n    except SQLAlchemyError as e:\n        db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Database error: {str(e)}\")\n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=400, detail=f\"Invalid data: {str(e)}\")\n</code></pre>"},{"location":"api/#university_app.api.main.update_timeslot","title":"<code>update_timeslot(time_slot_id, updated_timeslot, db=Depends(get_db))</code>  <code>async</code>","text":"<p>Update an existing time slot's details in the database.</p> Input <p>time_slot_id (int): The unique identifier of the time slot to update. updated_timeslot (TimeSlotCreate): The new time slot data. db (Session): Database session.</p> Output <p>TimeSlot: The updated time slot's details.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the time slot is not found, raises a 404 error.</p> Source code in <code>university_app/api/main.py</code> <pre><code>@app.put(\"/timeslots/{time_slot_id}\", response_model=TimeSlot, tags=[\"Time Slots\"])\nasync def update_timeslot(time_slot_id: int, updated_timeslot: TimeSlotCreate, db: Session = Depends(get_db)):\n    \"\"\"\n    Update an existing time slot's details in the database.\n\n    Input:\n        time_slot_id (int): The unique identifier of the time slot to update.\n        updated_timeslot (TimeSlotCreate): The new time slot data.\n        db (Session): Database session.\n\n    Output:\n        TimeSlot: The updated time slot's details.\n\n    Raises:\n        HTTPException: If the time slot is not found, raises a 404 error.\n    \"\"\"\n    timeslot = db.query(TimeSlotDB).filter(TimeSlotDB.time_slot_id == time_slot_id).first()\n    if not timeslot:\n        raise HTTPException(status_code=404, detail=\"Time slot not found\")\n    for key, value in updated_timeslot.model_dump().items():\n        setattr(timeslot, key, value)\n    db.commit()\n    db.refresh(timeslot)\n    return timeslot\n</code></pre>"},{"location":"api/#database-configuration","title":"Database Configuration","text":"<p>Database configuration module for SQLAlchemy connection setup. Provides database engine, base class, and session management for the application.</p> <p>This module handles database connection initialization and provides a dependency injection function for FastAPI endpoints to access database sessions.</p>"},{"location":"api/#university_app.api.Database.database.get_db","title":"<code>get_db()</code>","text":"<p>Description: Get a database session for dependency injection. Yields a database session and ensures it's closed after use.</p> Input <p>None</p> Output <p>Generator[Session]: Database session generator that yields a session</p> Source code in <code>university_app/api/Database/database.py</code> <pre><code>def get_db():\n    \"\"\"\n    Description:\n    Get a database session for dependency injection. Yields a database session and ensures it's closed after use.\n\n    Input:\n        None\n\n    Output:\n        Generator[Session]: Database session generator that yields a session\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre>"},{"location":"api/#schema-definitions","title":"Schema Definitions","text":"<p>Pydantic schema definitions for request and response validation. Provides data validation schemas for all API endpoints including student, course, and section models.</p>"},{"location":"api/#university_app.api.Database.schema.Cluster","title":"<code>Cluster</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for cluster</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Cluster(BaseModel):\n    \"\"\"Response schema for cluster\"\"\"\n    cluster_id: int\n    cluster_number: Optional[int] = None\n    theme: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.ClusterCreate","title":"<code>ClusterCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a cluster</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class ClusterCreate(BaseModel):\n    \"\"\"Request schema for creating a cluster\"\"\"\n    cluster_number: Optional[int] = None\n    theme: Optional[str] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Course","title":"<code>Course</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for course</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Course(BaseModel):\n    \"\"\"Response schema for course\"\"\"\n    id: int\n    name: str\n    credits: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.CourseCluster","title":"<code>CourseCluster</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for course_cluster</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class CourseCluster(BaseModel):\n    \"\"\"Response schema for course_cluster\"\"\"\n    course_id: int\n    cluster_id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.CourseClusterCreate","title":"<code>CourseClusterCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a course_cluster record</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class CourseClusterCreate(BaseModel):\n    \"\"\"Request schema for creating a course_cluster record\"\"\"\n    course_id: int\n    cluster_id: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.CourseCreate","title":"<code>CourseCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a course</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class CourseCreate(BaseModel):\n    \"\"\"Request schema for creating a course\"\"\"\n    name: str\n    credits: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Department","title":"<code>Department</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for department</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Department(BaseModel):\n    \"\"\"Response schema for department\"\"\"\n    dept_name: str\n    roomID: Optional[int] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.DepartmentCreate","title":"<code>DepartmentCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a department</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class DepartmentCreate(BaseModel):\n    \"\"\"Request schema for creating a department\"\"\"\n    dept_name: str\n    roomID: Optional[int] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.DraftSchedule","title":"<code>DraftSchedule</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for draft schedule</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class DraftSchedule(BaseModel):\n    \"\"\"Response schema for draft schedule\"\"\"\n    draft_schedule_id: int\n    student_id: int\n    name: str\n    created_at: str\n    updated_at: Optional[str] = None\n    section_ids: list[int] = []  # List of section IDs in this schedule\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.DraftScheduleCreate","title":"<code>DraftScheduleCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a draft schedule</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class DraftScheduleCreate(BaseModel):\n    \"\"\"Request schema for creating a draft schedule\"\"\"\n    student_id: int\n    name: str\n    section_ids: list[int]  # List of section IDs to include in the schedule\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.DraftScheduleUpdate","title":"<code>DraftScheduleUpdate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for updating a draft schedule</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class DraftScheduleUpdate(BaseModel):\n    \"\"\"Request schema for updating a draft schedule\"\"\"\n    name: Optional[str] = None\n    section_ids: Optional[list[int]] = None  # Replace all sections with this list\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.HasCourse","title":"<code>HasCourse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for hascourse (program-course relationship)</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class HasCourse(BaseModel):\n    \"\"\"Response schema for hascourse (program-course relationship)\"\"\"\n    prog_name: str\n    courseid: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.HasCourseCreate","title":"<code>HasCourseCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a hascourse record</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class HasCourseCreate(BaseModel):\n    \"\"\"Request schema for creating a hascourse record\"\"\"\n    prog_name: str\n    courseid: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Instructor","title":"<code>Instructor</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for instructor</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Instructor(BaseModel):\n    \"\"\"Response schema for instructor\"\"\"\n    id: int\n    name: str\n    bio_url: Optional[str] = None\n    room_id: Optional[int] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.InstructorCreate","title":"<code>InstructorCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating an instructor</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class InstructorCreate(BaseModel):\n    \"\"\"Request schema for creating an instructor\"\"\"\n    name: str\n    bio_url: Optional[str] = None\n    room_id: Optional[int] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Location","title":"<code>Location</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for location</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Location(BaseModel):\n    \"\"\"Response schema for location\"\"\"\n    room_id: int\n    building_room_name: str\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.LocationCreate","title":"<code>LocationCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a location</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class LocationCreate(BaseModel):\n    \"\"\"Request schema for creating a location\"\"\"\n    building_room_name: str\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Preferred","title":"<code>Preferred</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for preferred</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Preferred(BaseModel):\n    \"\"\"Response schema for preferred\"\"\"\n    student_id: int\n    course_id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.PreferredCreate","title":"<code>PreferredCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a preferred record</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class PreferredCreate(BaseModel):\n    \"\"\"Request schema for creating a preferred record\"\"\"\n    student_id: int\n    course_id: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Prerequisites","title":"<code>Prerequisites</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for prerequisites</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Prerequisites(BaseModel):\n    \"\"\"Response schema for prerequisites\"\"\"\n    course_id: int\n    prerequisite_id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.PrerequisitesCreate","title":"<code>PrerequisitesCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating prerequisites</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class PrerequisitesCreate(BaseModel):\n    \"\"\"Request schema for creating prerequisites\"\"\"\n    course_id: int\n    prerequisite_id: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Program","title":"<code>Program</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for program</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Program(BaseModel):\n    \"\"\"Response schema for program\"\"\"\n    prog_name: str\n    dept_name: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.ProgramCreate","title":"<code>ProgramCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a program</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class ProgramCreate(BaseModel):\n    \"\"\"Request schema for creating a program\"\"\"\n    prog_name: str\n    dept_name: Optional[str] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.RecommendationResult","title":"<code>RecommendationResult</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for recommendation result</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class RecommendationResult(BaseModel):\n    \"\"\"Response schema for recommendation result\"\"\"\n    id: int\n    student_id: int\n    course_id: Optional[int] = None\n    recommended_section_id: int\n    time_slot: Optional[int] = None\n    recommendation_score: Optional[str] = None\n    why_recommended: Optional[str] = None\n    slot_number: Optional[int] = None\n    model_version: Optional[str] = None\n    time_preference: Optional[str] = None\n    semester: Optional[str] = None\n    year: Optional[int] = None\n    course_name: Optional[str] = None\n    cluster: Optional[str] = None\n    credits: Optional[int] = None\n    created_at: str\n    updated_at: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.RecommendationResultCreate","title":"<code>RecommendationResultCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a recommendation result</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class RecommendationResultCreate(BaseModel):\n    \"\"\"Request schema for creating a recommendation result\"\"\"\n    student_id: int\n    course_id: Optional[int] = None\n    recommended_section_id: int\n    time_slot: Optional[int] = None\n    recommendation_score: Optional[str] = None\n    why_recommended: Optional[str] = None\n    slot_number: Optional[int] = None\n    model_version: Optional[str] = None\n    time_preference: Optional[str] = None\n    semester: Optional[str] = None\n    year: Optional[int] = None\n    course_name: Optional[str] = None\n    cluster: Optional[str] = None\n    credits: Optional[int] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for section</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Section(BaseModel):\n    \"\"\"Response schema for section\"\"\"\n    id: int\n    capacity: int\n    roomID: int\n    duration: Optional[str] = None\n    time_slot_id: int\n    course_id: int\n    instructor_id: int\n    syllabus_url: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.SectionCreate","title":"<code>SectionCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a section</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class SectionCreate(BaseModel):\n    \"\"\"Request schema for creating a section\"\"\"\n    capacity: int\n    roomID: int\n    duration: Optional[str] = None\n    time_slot_id: int\n    course_id: int\n    instructor_id: int\n    syllabus_url: Optional[str] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.SectionName","title":"<code>SectionName</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for section_name</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class SectionName(BaseModel):\n    \"\"\"Response schema for section_name\"\"\"\n    section_name: str\n    section_id: int\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.SectionNameCreate","title":"<code>SectionNameCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a section_name</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class SectionNameCreate(BaseModel):\n    \"\"\"Request schema for creating a section_name\"\"\"\n    section_name: str\n    section_id: int\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Student","title":"<code>Student</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for student</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Student(BaseModel):\n    \"\"\"Response schema for student\"\"\"\n    student_id: int\n    student_name: str\n    credit: Optional[int] = None\n    program_name: str\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.StudentCreate","title":"<code>StudentCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a student</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class StudentCreate(BaseModel):\n    \"\"\"Request schema for creating a student\"\"\"\n    student_name: str\n    credit: Optional[int] = None\n    program_name: str\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Takes","title":"<code>Takes</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for takes (student enrollment)</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Takes(BaseModel):\n    \"\"\"Response schema for takes (student enrollment)\"\"\"\n    student_id: int\n    section_id: int\n    status: Optional[str] = None\n    grade: Optional[str] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.TakesCreate","title":"<code>TakesCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a takes record</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class TakesCreate(BaseModel):\n    \"\"\"Request schema for creating a takes record\"\"\"\n    student_id: int\n    section_id: int\n    status: Optional[str] = None\n    grade: Optional[str] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.TimeSlot","title":"<code>TimeSlot</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for time slot</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class TimeSlot(BaseModel):\n    \"\"\"Response schema for time slot\"\"\"\n    time_slot_id: int\n    day_of_week: str\n    start_time: str\n    end_time: str\n    year: int\n    semester: str\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.TimeSlotCreate","title":"<code>TimeSlotCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a time slot</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class TimeSlotCreate(BaseModel):\n    \"\"\"Request schema for creating a time slot\"\"\"\n    day_of_week: str\n    start_time: str\n    end_time: str\n    year: int\n    semester: str\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.User","title":"<code>User</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for user</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class User(BaseModel):\n    \"\"\"Response schema for user\"\"\"\n    user_id: int\n    username: str\n    password: str  # Note: In production, never return password in response\n    student_id: Optional[int] = None\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.UserCreate","title":"<code>UserCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a user</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class UserCreate(BaseModel):\n    \"\"\"Request schema for creating a user\"\"\"\n    username: str\n    password: str\n    student_id: Optional[int] = None\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.Works","title":"<code>Works</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Response schema for works (instructor-department relationship)</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class Works(BaseModel):\n    \"\"\"Response schema for works (instructor-department relationship)\"\"\"\n    instructorid: int\n    dept_name: str\n\n    class Config:\n        from_attributes = True\n</code></pre>"},{"location":"api/#university_app.api.Database.schema.WorksCreate","title":"<code>WorksCreate</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Request schema for creating a works record</p> Source code in <code>university_app/api/Database/schema.py</code> <pre><code>class WorksCreate(BaseModel):\n    \"\"\"Request schema for creating a works record\"\"\"\n    instructorid: int\n    dept_name: str\n</code></pre>"},{"location":"api_models/","title":"API Models Documentation","text":""},{"location":"api_models/#overview","title":"Overview","text":"<p>This document describes the database models used in the API component.</p>"},{"location":"api_models/#database-models","title":"Database Models","text":""},{"location":"api_models/#university_app.api.Database.models","title":"<code>university_app.api.Database.models</code>","text":"<p>Database models for the University Course Management System. Defines all SQLAlchemy database models for the complete university system including students, courses, and sections.</p>"},{"location":"api_models/#university_app.api.Database.models.ClusterDB","title":"<code>ClusterDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Cluster table. Represents academic clusters (thematic groupings of courses).</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class ClusterDB(Base):\n    \"\"\"\n    Database model for Cluster table.\n    Represents academic clusters (thematic groupings of courses).\n    \"\"\"\n    __tablename__ = \"clusters\"\n\n    cluster_id = Column(Integer, primary_key=True)\n    cluster_number = Column(Integer, nullable=True)\n    theme = Column(String(500), nullable=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.CourseClusterDB","title":"<code>CourseClusterDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Course-Cluster junction table (many-to-many relationship). Links courses to clusters.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class CourseClusterDB(Base):\n    \"\"\"\n    Database model for Course-Cluster junction table (many-to-many relationship).\n    Links courses to clusters.\n    \"\"\"\n    __tablename__ = \"course_cluster\"\n\n    course_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)\n    cluster_id = Column(Integer, ForeignKey('clusters.cluster_id'), primary_key=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.CourseDB","title":"<code>CourseDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Course table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class CourseDB(Base):\n    \"\"\"Database model for Course table.\"\"\"\n    __tablename__ = \"courses\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    credits = Column(Integer, nullable=False)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.DepartmentDB","title":"<code>DepartmentDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Department table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class DepartmentDB(Base):\n    \"\"\"Database model for Department table.\"\"\"\n    __tablename__ = \"departments\"\n\n    dept_name = Column(String, primary_key=True)\n    roomID = Column(Integer, ForeignKey('locations.room_id'))\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.DraftScheduleDB","title":"<code>DraftScheduleDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for draft schedules created by students.</p> <p>Stores draft schedule metadata. The actual sections in each schedule are stored in the draft_schedule_sections junction table.</p> <p>Relationships: - One student can have many draft schedules (one-to-many) - One draft schedule can have many sections (many-to-many via draft_schedule_sections)</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class DraftScheduleDB(Base):\n    \"\"\"\n    Database model for draft schedules created by students.\n\n    Stores draft schedule metadata. The actual sections in each schedule\n    are stored in the draft_schedule_sections junction table.\n\n    Relationships:\n    - One student can have many draft schedules (one-to-many)\n    - One draft schedule can have many sections (many-to-many via draft_schedule_sections)\n    \"\"\"\n    __tablename__ = \"draft_schedules\"\n\n    draft_schedule_id = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    student_id = Column(Integer, ForeignKey('students.student_id'), nullable=False, index=True)\n    name = Column(String(100), nullable=False)  # e.g., \"Schedule 1\", \"Fall 2025 Draft\"\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.DraftScheduleSectionDB","title":"<code>DraftScheduleSectionDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for draft_schedule_sections junction table.</p> <p>Links draft schedules to sections (many-to-many relationship). This allows a draft schedule to contain multiple sections, and a section can be in multiple draft schedules (though typically not).</p> <p>Relationships: - Links draft_schedules to sections - Composite primary key ensures no duplicate section entries per schedule</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class DraftScheduleSectionDB(Base):\n    \"\"\"\n    Database model for draft_schedule_sections junction table.\n\n    Links draft schedules to sections (many-to-many relationship).\n    This allows a draft schedule to contain multiple sections,\n    and a section can be in multiple draft schedules (though typically not).\n\n    Relationships:\n    - Links draft_schedules to sections\n    - Composite primary key ensures no duplicate section entries per schedule\n    \"\"\"\n    __tablename__ = \"draft_schedule_sections\"\n\n    draft_schedule_id = Column(Integer, ForeignKey('draft_schedules.draft_schedule_id', ondelete='CASCADE'), primary_key=True, nullable=False, index=True)\n    section_id = Column(Integer, ForeignKey('sections.id', ondelete='CASCADE'), primary_key=True, nullable=False, index=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.HasCourseDB","title":"<code>HasCourseDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for HasCourse table (junction table: program-course).</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class HasCourseDB(Base):\n    \"\"\"Database model for HasCourse table (junction table: program-course).\"\"\"\n    __tablename__ = \"hascourse\"\n\n    prog_name = Column(String, ForeignKey('programs.prog_name'), primary_key=True)\n    courseid = Column(Integer, ForeignKey('courses.id'), primary_key=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.InstructorDB","title":"<code>InstructorDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Instructor table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class InstructorDB(Base):\n    \"\"\"Database model for Instructor table.\"\"\"\n    __tablename__ = \"instructors\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    bio_url = Column(String(255), nullable=True)\n    room_id = Column(Integer, ForeignKey('locations.room_id'), nullable=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.LocationDB","title":"<code>LocationDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Location table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class LocationDB(Base):\n    \"\"\"Database model for Location table.\"\"\"\n    __tablename__ = \"locations\"\n\n    room_id = Column(Integer, primary_key=True)\n    building_room_name = Column(String(100), nullable=False)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.PreferredDB","title":"<code>PreferredDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Preferred table - junction table linking students to courses. Represents student preferences for courses.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class PreferredDB(Base):\n    \"\"\"\n    Database model for Preferred table - junction table linking students to courses.\n    Represents student preferences for courses.\n    \"\"\"\n    __tablename__ = \"preferred\"\n\n    student_id = Column(Integer, ForeignKey('students.student_id'), primary_key=True)\n    course_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.PrerequisitesDB","title":"<code>PrerequisitesDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Prerequisites table (junction table).</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class PrerequisitesDB(Base):\n    \"\"\"Database model for Prerequisites table (junction table).\"\"\"\n    __tablename__ = \"prerequisites\"\n\n    course_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)\n    prerequisite_id = Column(Integer, ForeignKey('courses.id'), primary_key=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.ProgramDB","title":"<code>ProgramDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Program table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class ProgramDB(Base):\n    \"\"\"Database model for Program table.\"\"\"\n    __tablename__ = \"programs\"\n\n    prog_name = Column(String, primary_key=True)\n    dept_name = Column(String(50), ForeignKey('departments.dept_name'), nullable=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.RecommendationResultDB","title":"<code>RecommendationResultDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for storing semester recommendation results.</p> <p>This table stores the output of the semester recommendation system, including full semester schedules recommended for students.</p> <p>Relationships: - Links to students (who the recommendation is for) - Links to sections (specific section recommended) - Links to time_slots (when the section is offered)</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class RecommendationResultDB(Base):\n    \"\"\"\n    Database model for storing semester recommendation results.\n\n    This table stores the output of the semester recommendation system,\n    including full semester schedules recommended for students.\n\n    Relationships:\n    - Links to students (who the recommendation is for)\n    - Links to sections (specific section recommended)\n    - Links to time_slots (when the section is offered)\n    \"\"\"\n    __tablename__ = \"recommendation_results\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True, index=True)\n\n    # Foreign keys\n    student_id = Column(Integer, ForeignKey('students.student_id'), nullable=False, index=True)\n    course_id = Column(Integer, ForeignKey('courses.id'), nullable=True)\n    recommended_section_id = Column(Integer, ForeignKey('sections.id'), nullable=False)\n    time_slot = Column(Integer, ForeignKey('time_slots.time_slot_id'), nullable=True)\n\n    # Recommendation metadata\n    course_name = Column(String(200), nullable=True)\n    cluster = Column(String(200), nullable=True)\n    credits = Column(Integer, nullable=True)\n\n    # Recommendation logic\n    recommendation_score = Column(String(50), nullable=True)  # Score/ranking (can be string for flexibility)\n    why_recommended = Column(Text, nullable=True)  # JSON string or text explaining why this was recommended\n    slot_number = Column(Integer, nullable=True)  # Position in semester schedule (1-5)\n\n    # Model and context\n    model_version = Column(String(50), nullable=True)  # e.g., 'semester_scheduler_v1', 'baseline_v1'\n    time_preference = Column(String(20), nullable=True)  # 'morning', 'afternoon', 'evening'\n    semester = Column(String(20), nullable=True)  # 'Fall', 'Spring', 'Summer' - kept for backward compatibility\n    year = Column(Integer, nullable=True)  # Academic year - kept for backward compatibility\n\n    # Timestamps\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.SectionDB","title":"<code>SectionDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Section table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class SectionDB(Base):\n    \"\"\"Database model for Section table.\"\"\"\n    __tablename__ = \"sections\"\n\n    id = Column(Integer, primary_key=True)\n    capacity = Column(Integer, nullable=False)\n    roomID = Column(Integer, ForeignKey('locations.room_id'), nullable=False)\n    duration = Column(String(50))\n    time_slot_id = Column(Integer, ForeignKey('time_slots.time_slot_id'), nullable=False)\n    course_id = Column(Integer, ForeignKey('courses.id'), nullable=False)\n    instructor_id = Column(Integer, ForeignKey('instructors.id'), nullable=False)\n    syllabus_url = Column(String(255))\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.SectionNameDB","title":"<code>SectionNameDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for SectionName table.</p> <p>Attributes:</p> Name Type Description <code>section_name</code> <p>Section letter/name (e.g., 'A', 'B', 'Section 1')</p> <code>section_id</code> <p>Foreign key to sections table</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class SectionNameDB(Base):\n    \"\"\"\n    Database model for SectionName table.\n\n    Attributes:\n        section_name: Section letter/name (e.g., 'A', 'B', 'Section 1')\n        section_id: Foreign key to sections table\n    \"\"\"\n    __tablename__ = \"section_name\"\n\n    section_name = Column(String, primary_key=True)  # section_letter\n    section_id = Column(Integer, ForeignKey('sections.id'), primary_key=True, nullable=False)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.StudentDB","title":"<code>StudentDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Student table.</p> <p>Attributes:</p> Name Type Description <code>student_id</code> <p>Primary key, auto-incrementing integer</p> <code>student_name</code> <p>Student's name</p> <code>credit</code> <p>Number of credits the student has</p> <code>program_name</code> <p>Program name the student is enrolled in</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class StudentDB(Base):\n    \"\"\"\n    Database model for Student table.\n\n    Attributes:\n        student_id: Primary key, auto-incrementing integer\n        student_name: Student's name\n        credit: Number of credits the student has\n        program_name: Program name the student is enrolled in\n    \"\"\"\n    __tablename__ = \"students\"\n\n    student_id = Column(Integer, primary_key=True, index=True)\n    student_name = Column(String(100), nullable=False)\n    credit = Column(Integer, nullable=True)\n    program_name = Column(String(100), nullable=False)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.TakesDB","title":"<code>TakesDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Takes table (student enrollments).</p> <p>Attributes:</p> Name Type Description <code>student_id</code> <p>Foreign key to students table (part of primary key)</p> <code>section_id</code> <p>Foreign key to sections table (part of primary key)</p> <code>status</code> <p>Enrollment status (e.g., 'enrolled', 'completed', 'dropped')</p> <code>grade</code> <p>Grade received (e.g., 'A', 'B+', 'F', 'P', 'NP') or None</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class TakesDB(Base):\n    \"\"\"\n    Database model for Takes table (student enrollments).\n\n    Attributes:\n        student_id: Foreign key to students table (part of primary key)\n        section_id: Foreign key to sections table (part of primary key)\n        status: Enrollment status (e.g., 'enrolled', 'completed', 'dropped')\n        grade: Grade received (e.g., 'A', 'B+', 'F', 'P', 'NP') or None\n    \"\"\"\n    __tablename__ = \"takes\"\n\n    student_id = Column(Integer, ForeignKey('students.student_id'), primary_key=True)\n    section_id = Column(Integer, ForeignKey('sections.id'), primary_key=True)\n    status = Column(String(20))  # e.g., 'enrolled', 'completed', 'dropped'\n    grade = Column(String(5), nullable=True)  # e.g., 'A', 'B+', 'F', 'P', 'NP'\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.TimeSlotDB","title":"<code>TimeSlotDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for TimeSlot table.</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class TimeSlotDB(Base):\n    \"\"\"Database model for TimeSlot table.\"\"\"\n    __tablename__ = \"time_slots\"\n\n    time_slot_id = Column(Integer, primary_key=True)\n    day_of_week = Column(String(3), nullable=False)\n    start_time = Column(String, nullable=False)\n    end_time = Column(String, nullable=False)\n    year = Column(Integer, nullable=False)\n    semester = Column(String, nullable=False)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.UserDB","title":"<code>UserDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for User table.</p> <p>Stores user login information and links to a student profile.</p> <p>Attributes:</p> Name Type Description <code>user_id</code> <p>Primary key, auto-incrementing integer</p> <code>username</code> <p>Unique username for login</p> <code>password</code> <p>Hashed password (unique constraint)</p> <code>student_id</code> <p>Foreign key to students table (1-to-1 relationship)</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class UserDB(Base):\n    \"\"\"\n    Database model for User table.\n\n    Stores user login information and links to a student profile.\n\n    Attributes:\n        user_id: Primary key, auto-incrementing integer\n        username: Unique username for login\n        password: Hashed password (unique constraint)\n        student_id: Foreign key to students table (1-to-1 relationship)\n    \"\"\"\n    __tablename__ = \"users\"\n\n    user_id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(50), nullable=False, unique=True)\n    password = Column(String(70), nullable=False, unique=True)\n    student_id = Column(Integer, ForeignKey('students.student_id'), nullable=True)\n</code></pre>"},{"location":"api_models/#university_app.api.Database.models.WorksDB","title":"<code>WorksDB</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for Works table (junction table: instructor-department).</p> Source code in <code>university_app/api/Database/models.py</code> <pre><code>class WorksDB(Base):\n    \"\"\"Database model for Works table (junction table: instructor-department).\"\"\"\n    __tablename__ = \"works\"\n\n    instructorid = Column(Integer, ForeignKey('instructors.id'), primary_key=True) \n    dept_name = Column(String, ForeignKey('departments.dept_name'), primary_key=True)\n</code></pre>"},{"location":"app/","title":"APP Documentation","text":""},{"location":"app/#overview","title":"Overview","text":"<p>The APP component is a React-based frontend application built with TypeScript and Vite.</p>"},{"location":"app/#technology-stack","title":"Technology Stack","text":"<ul> <li>React: UI framework</li> <li>TypeScript: Type safety</li> <li>Vite: Build tool and dev server</li> <li>Tailwind CSS: Styling</li> <li>shadcn/ui: UI components</li> </ul>"},{"location":"app/#features","title":"Features","text":"<ul> <li>Modern, responsive user interface</li> <li>Course browsing and search</li> <li>Student enrollment management</li> <li>Instructor information display</li> <li>Program and department navigation</li> </ul>"},{"location":"app/#development","title":"Development","text":"<p>To run the development server:</p> <pre><code>cd university_app/app\nnpm install\nnpm run dev\n</code></pre> <p>The app will be available at <code>http://localhost:5173</code> (or the configured port).</p>"},{"location":"app/#building","title":"Building","text":"<p>To build for production:</p> <pre><code>npm run build\n</code></pre>"},{"location":"app/#docker","title":"Docker","text":"<p>The app can be run in a Docker container with Nginx for serving static files. See the <code>Dockerfile</code> and <code>nginx.conf</code> in the <code>app</code> directory for details.</p>"},{"location":"etl/","title":"ETL Documentation","text":""},{"location":"etl/#overview","title":"Overview","text":"<p>The ETL (Extract, Transform, Load) component is responsible for generating and loading university data into the PostgreSQL database.</p>"},{"location":"etl/#data-generation","title":"Data Generation","text":"<p>ETL Script for Generating and Loading University Data into a Database.</p> <p>This script generates data for students, instructors, courses, departments, sections, etc. and saves the data to CSV files according to the ERD.</p> Usage <p>python generate_university_data.py</p> Prerequisites <ul> <li>Database.university_data_generator module must be available</li> <li>pandas must be installed</li> </ul>"},{"location":"etl/#university_app.etl.generate_university_data.main","title":"<code>main()</code>","text":"Description <p>Generate the university dataset, write each table to CSV, and print a summary with sample records.</p> Input <p>None (uses module-level configuration constants)</p> Output <p>None</p> Source code in <code>university_app/etl/generate_university_data.py</code> <pre><code>def main():\n    \"\"\"\n    Description:\n        Generate the university dataset, write each table to CSV, and print a summary with sample records.\n\n    Input:\n        None (uses module-level configuration constants)\n\n    Output:\n        None\n    \"\"\"\n    logger.info(\"Starting university data generation...\")\n\n    # Generate the dataset\n    dataset = generate_university_dataset(\n        num_students=NUM_STUDENTS,\n        num_locations=NUM_LOCATIONS,\n        num_sections_per_course=NUM_SECTIONS_PER_COURSE,\n        current_year=CURRENT_YEAR,\n    )\n\n    # Create output directory\n    output_dir = \"data\"\n    os.makedirs(output_dir, exist_ok=True)\n\n    # Save each table to CSV\n    for table_name in TABLE_NAMES:\n        df = pd.DataFrame(dataset[table_name])\n        csv_path = f\"{output_dir}/{table_name}.csv\"\n        df.to_csv(csv_path, index=False)\n        logger.info(f\"Saved {len(df)} {table_name} records to {csv_path}\")\n\n    # Print summary statistics\n    print(\"\\n\" + \"=\" * 60)\n    print(\"DATA GENERATION SUMMARY\")\n    print(\"=\" * 60)\n    print(f\"Students: {len(dataset['student'])}\")\n    print(f\"Locations: {len(dataset['location'])}\")\n    print(f\"Instructors: {len(dataset['instructor'])}\")\n    print(f\"Departments: {len(dataset['department'])}\")\n    print(f\"Programs: {len(dataset['program'])}\")\n    print(f\"Courses: {len(dataset['course'])}\")\n    print(f\"Time Slots: {len(dataset['time_slot'])}\")\n    print(f\"Sections: {len(dataset['section'])}\")\n    print(f\"Prerequisites: {len(dataset['prerequisites'])}\")\n    print(f\"Enrollments (takes): {len(dataset['takes'])}\")\n    print(f\"Instructor-Department (works): {len(dataset['works'])}\")\n    print(f\"Program-Course (hascourse): {len(dataset['hascourse'])}\")\n    print(f\"Clusters: {len(dataset['cluster'])}\")\n    print(f\"Course-Cluster: {len(dataset['course_cluster'])}\")\n    print(f\"Preferred (student preferences): {len(dataset['preferred'])}\")\n    print(f\"Users: {len(dataset['users'])}\")\n    print(f\"Section Names: {len(dataset['section_name'])}\")\n\n    # Show sample data\n    print(\"\\n\" + \"=\" * 60)\n    print(\"SAMPLE RECORDS\")\n    print(\"=\" * 60)\n\n    if len(dataset[\"student\"]) &gt; 0:\n        print(\"\\n--- Sample Student ---\")\n        sample_student = dataset[\"student\"][0]\n        print(f\"ID: {sample_student['id']}\")\n        print(f\"Name: {sample_student['name']}\")\n        print(f\"Credits: {sample_student['credit']}\")\n        print(f\"Program Name: {sample_student['program_name']}\")\n\n    if len(dataset[\"course\"]) &gt; 0:\n        print(\"\\n--- Sample Course ---\")\n        sample_course = dataset[\"course\"][0]\n        print(f\"ID: {sample_course['id']}\")\n        print(f\"Name: {sample_course['name']}\")\n        print(f\"Credits: {sample_course['credits']}\")\n\n    if len(dataset[\"instructor\"]) &gt; 0:\n        print(\"\\n--- Sample Instructor ---\")\n        sample_instructor = dataset[\"instructor\"][0]\n        print(f\"ID: {sample_instructor['id']}\")\n        print(f\"Name: {sample_instructor['name']}\")\n        print(f\"Bio URL: {sample_instructor['bio_url']}\")\n        print(f\"Room ID: {sample_instructor['room_id']}\")\n\n    if len(dataset[\"section\"]) &gt; 0:\n        print(\"\\n--- Sample Section ---\")\n        sample_section = dataset[\"section\"][0]\n        print(f\"ID: {sample_section['id']}\")\n        print(f\"Course ID: {sample_section['course_id']}\")\n        print(f\"Instructor ID: {sample_section['instructor_id']}\")\n        print(f\"Capacity: {sample_section['capacity']}\")\n        print(f\"Duration: {sample_section['duration']}\")\n        print(f\"Time Slot ID: {sample_section['time_slot_id']}\")\n        print(f\"Room ID: {sample_section['roomID']}\")\n\n    if len(dataset[\"time_slot\"]) &gt; 0:\n        print(\"\\n--- Sample Time Slot ---\")\n        sample_time_slot = dataset[\"time_slot\"][0]\n        print(f\"ID: {sample_time_slot['time_slot_id']}\")\n        print(f\"Day: {sample_time_slot['day_of_week']}\")\n        print(f\"Time: {sample_time_slot['start_time']} - {sample_time_slot['end_time']}\")\n        print(f\"Year: {sample_time_slot['year']}\")\n        print(f\"Semester: {sample_time_slot['semester']}\")\n\n    if len(dataset[\"takes\"]) &gt; 0:\n        print(\"\\n--- Sample Enrollment (takes) ---\")\n        sample_takes = dataset[\"takes\"][0]\n        print(f\"Student ID: {sample_takes['student_id']}\")\n        print(f\"Section ID: {sample_takes['section_id']}\")\n        print(f\"Status: {sample_takes['status']}\")\n        print(f\"Grade: {sample_takes['grade']}\")\n\n    if len(dataset[\"users\"]) &gt; 0:\n        print(\"\\n--- Sample User ---\")\n        sample_user = dataset[\"users\"][0]\n        print(f\"User ID: {sample_user['user_id']}\")\n        print(f\"Username: {sample_user['username']}\")\n        print(f\"Password: {sample_user['password']}\")\n        print(f\"Student ID: {sample_user['student_id']}\")\n\n    if len(dataset[\"section_name\"]) &gt; 0:\n        print(\"\\n--- Sample Section Name ---\")\n        sample_section_name = dataset[\"section_name\"][0]\n        print(f\"Section Name: {sample_section_name['section_name']}\")\n        print(f\"Section ID: {sample_section_name['section_id']}\")\n\n    print(\"\\n\" + \"=\" * 60)\n    print(\"Data generation complete!\")\n    print(\"=\" * 60)\n    print(f\"\\nAll CSV files saved to: {output_dir}/\")\n    print(\"Files created:\")\n    for table_name in TABLE_NAMES:\n        print(f\"  - {table_name}.csv\")\n</code></pre>"},{"location":"etl/#data-loading","title":"Data Loading","text":"<p>Load CSV Data into Database - ETL Testing Script.</p> <p>This script allows the ETL developer to test loading generated CSV files into the database. This ensures the ETL process works end-to-end.</p> Usage <p>python load_data_to_db.py</p> Prerequisites <ul> <li>CSV files must be generated first (run generate_university_data.py)</li> <li>DATABASE_URL must be set in .env file</li> <li>Database must be running and accessible</li> </ul>"},{"location":"etl/#university_app.etl.load_data_to_db.generate_recommendations_for_all_students","title":"<code>generate_recommendations_for_all_students(db_session)</code>","text":"<p>Description: Generate recommendations for all students in the database. Uses default 'any' time preference.</p> Input <p>db_session: SQLAlchemy database session</p> Output <p>None</p> Source code in <code>university_app/etl/load_data_to_db.py</code> <pre><code>def generate_recommendations_for_all_students(db_session):\n    \"\"\"\n    Description:\n    Generate recommendations for all students in the database.\n    Uses default 'any' time preference.\n\n    Input:\n        db_session: SQLAlchemy database session\n\n    Output:\n        None\n    \"\"\"\n    if not RECOMMENDER_AVAILABLE:\n        logger.warning(\"Recommender not available, skipping recommendation generation\")\n        return\n\n    try:\n        # Get all students\n        students = db_session.query(Student).all()\n        if not students:\n            logger.info(\"No students found, skipping recommendation generation\")\n            return\n\n        logger.info(f\"Generating recommendations for {len(students)} students...\")\n\n        # Generate recommendations for each student\n        total_generated = 0\n        for student in students:\n            try:\n                recommendations = generate_recommendations_for_student(\n                    engine=engine,\n                    student_id=student.student_id,\n                    time_preference='any',  # Default to 'any'\n                    current_year=2025,\n                    current_semester='Fall'\n                )\n\n                if not recommendations:\n                    logger.debug(f\"No recommendations for student {student.student_id}\")\n                    continue\n\n                # Save recommendations to database\n                for slot_num, rec in enumerate(recommendations, 1):\n                    # Get time_slot_id from section\n                    section = db_session.query(Section).filter(Section.id == int(rec['section_id'])).first()\n                    time_slot_id = section.time_slot_id if section else None\n\n                    # Convert why_recommended list to string\n                    why_recommended_str = ', '.join(rec.get('why_recommended', []))\n\n                    result_data = {\n                        'student_id': student.student_id,\n                        'course_id': int(rec['course_id']),\n                        'recommended_section_id': int(rec['section_id']),\n                        'course_name': rec['course_name'],\n                        'cluster': rec.get('cluster', ''),\n                        'credits': int(rec.get('credits', 0)),\n                        'time_slot': int(time_slot_id) if time_slot_id is not None else None,\n                        'recommendation_score': str(rec.get('score', '1.0')),\n                        'why_recommended': why_recommended_str,\n                        'slot_number': slot_num,\n                        'model_version': 'semester_scheduler_v1',\n                        'time_preference': 'any',\n                        'semester': 'Fall',\n                        'year': 2025\n                    }\n\n                    recommendation = RecommendationResult(**result_data)\n                    db_session.add(recommendation)\n                    total_generated += 1\n\n                # Commit after each student to avoid large transactions\n                db_session.commit()\n\n            except Exception as e:\n                logger.warning(f\"Failed to generate recommendations for student {student.student_id}: {e}\")\n                db_session.rollback()\n                continue\n\n        logger.info(f\"\u2705 Generated {total_generated} recommendations for {len(students)} students\")\n\n    except Exception as e:\n        logger.error(f\"Error generating recommendations: {e}\")\n        db_session.rollback()\n        raise\n</code></pre>"},{"location":"etl/#university_app.etl.load_data_to_db.load_csv_to_db","title":"<code>load_csv_to_db(csv_path, model_class, db_session)</code>","text":"Description <p>Load a single CSV file into the corresponding database table using the given model.</p> Input <p>csv_path (str): Path to the CSV file (assumed to exist - check in caller) model_class: SQLAlchemy model class db_session: SQLAlchemy Session</p> Output <p>int: Number of records inserted into the table</p> Source code in <code>university_app/etl/load_data_to_db.py</code> <pre><code>def load_csv_to_db(csv_path: str, model_class, db_session):\n    \"\"\"\n    Description:\n        Load a single CSV file into the corresponding database table using the given model.\n\n    Input:\n        csv_path (str): Path to the CSV file (assumed to exist - check in caller)\n        model_class: SQLAlchemy model class\n        db_session: SQLAlchemy Session\n\n    Output:\n        int: Number of records inserted into the table\n    \"\"\"\n    df = pd.read_csv(csv_path)\n    if df.empty:\n        error_msg = f\"CSV file is empty: {csv_path}\"\n        logger.error(error_msg)\n        raise ValueError(error_msg)\n\n    # Column name mapping: CSV file name -&gt; CSV column -&gt; Model field\n    csv_filename = os.path.basename(csv_path).replace(\".csv\", \"\")\n\n    column_mapping = {\n        \"student\": {\"id\": \"student_id\", \"name\": \"student_name\"},\n    }\n\n    mapping = column_mapping.get(csv_filename, {})\n\n    # Rename columns if mapping exists\n    if mapping:\n        df = df.rename(columns=mapping)\n\n    # Special handling for programs - deduplicate by prog_name (primary key)\n    if csv_filename == \"program\":\n        df = df.drop_duplicates(subset=[\"prog_name\"], keep=\"first\")\n        logger.info(f\"Deduplicated programs: {len(df)} unique programs\")\n\n    # Special handling for hascourse - deduplicate by (prog_name, courseid) composite key\n    if csv_filename == \"hascourse\":\n        original_count = len(df)\n        df = df.drop_duplicates(subset=[\"prog_name\", \"courseid\"], keep=\"first\")\n        if len(df) &lt; original_count:\n            logger.info(\n                f\"Deduplicated hascourse: {len(df)} unique records \"\n                f\"(removed {original_count - len(df)} duplicates)\"\n            )\n\n    # Special handling for section_name - deduplicate by (section_name, section_id) composite key\n    if csv_filename == \"section_name\":\n        original_count = len(df)\n        df = df.drop_duplicates(subset=[\"section_name\", \"section_id\"], keep=\"first\")\n        if len(df) &lt; original_count:\n            logger.info(\n                f\"Deduplicated section_name: {len(df)} unique records \"\n                f\"(removed {original_count - len(df)} duplicates)\"\n            )\n\n    # Convert DataFrame rows to model instances\n    records = []\n    for _, row in df.iterrows():\n        record_dict = row.to_dict()\n        record_dict = {k: (None if pd.isna(v) else v) for k, v in record_dict.items()}\n\n        try:\n            record = model_class(**record_dict)\n            records.append(record)\n        except Exception as e:\n            logger.error(f\"Error creating {model_class.__name__} from row: {record_dict}\")\n            logger.error(f\"Error: {e}\")\n            raise\n\n    # Insert records (using add_all instead of bulk_save_objects to properly handle\n    # foreign keys and composite primary keys)\n    # For tables with composite primary keys or foreign keys, we need to flush explicitly\n    try:\n        if len(records) == 0:\n            logger.warning(f\"No records to insert for {model_class.__tablename__}\")\n            return 0\n\n        # Add records to session\n        db_session.add_all(records)\n\n        # Flush to send INSERT statements to database (important for foreign key validation)\n        # This will raise an error if there are foreign key constraint violations\n        db_session.flush()\n\n        # Commit the transaction\n        db_session.commit()\n\n        # Verify the records were actually inserted\n        inserted_count = db_session.query(model_class).count()\n        logger.info(\n            f\"Loaded {len(records)} records from {csv_path} into {model_class.__tablename__} \"\n            f\"(verified: {inserted_count} total records in table)\"\n        )\n        return len(records)\n    except Exception as e:\n        db_session.rollback()\n        error_msg = str(e).lower()\n        if \"duplicate key\" in error_msg or \"unique constraint\" in error_msg:\n            logger.error(\n                f\"Duplicate records detected in {model_class.__tablename__}. \"\n                f\"This may indicate a partial load or data issue. Error: {e}\"\n            )\n            # Don't silently fail - raise the error so we know what went wrong\n            raise\n        if \"foreign key\" in error_msg or \"violates foreign key constraint\" in error_msg:\n            logger.error(\n                f\"Foreign key constraint violation in {model_class.__tablename__}. \"\n                f\"This may indicate missing parent records. Error: {e}\"\n            )\n            if records:\n                sample = records[0]\n                logger.error(f\"Sample record that failed: {sample.__dict__ if hasattr(sample, '__dict__') else 'N/A'}\")\n            raise\n        logger.error(f\"Error loading {csv_path} into database: {e}\")\n        logger.error(f\"Model: {model_class.__name__}, Table: {model_class.__tablename__}\")\n        logger.error(f\"Number of records attempted: {len(records)}\")\n        if records:\n            logger.error(f\"First record sample: {records[0].__dict__ if hasattr(records[0], '__dict__') else 'N/A'}\")\n        raise\n</code></pre>"},{"location":"etl/#university_app.etl.load_data_to_db.main","title":"<code>main()</code>","text":"Description <p>Create tables if needed and load all CSVs into the database in dependency order.</p> <p>Clears existing data first to avoid duplicates, then loads fresh data.</p> Input <p>None (uses global LOAD_ORDER and TABLE_MODELS)</p> Output <p>None</p> Source code in <code>university_app/etl/load_data_to_db.py</code> <pre><code>def main():\n    \"\"\"\n    Description:\n        Create tables if needed and load all CSVs into the database in dependency order.\n    Clears existing data first to avoid duplicates, then loads fresh data.\n\n    Input:\n        None (uses global LOAD_ORDER and TABLE_MODELS)\n\n    Output:\n        None\n    \"\"\"\n    logger.info(\"Starting CSV to database load process...\")\n\n    # Create tables if they don't exist\n    logger.info(\"Creating database tables...\")\n    create_tables()\n    logger.info(\"Database tables created/verified.\")\n\n    # Get database session\n    db_gen = get_db()\n    db = next(db_gen)\n\n    try:\n        # Clear recommendation_results if sections change (they reference sections that may be updated)\n        # This ensures recommendations stay valid if the course catalog changes\n        logger.info(\"Clearing recommendation_results (will be regenerated by users)...\")\n        try:\n            db.execute(text(\"DELETE FROM recommendation_results\"))\n            logger.info(\"Cleared recommendation_results table\")\n        except Exception as e:\n            logger.debug(f\"Could not clear recommendation_results (may not exist): {e}\")\n\n        db.commit()\n\n        # Preserve draft_schedules and draft_schedule_sections - these are user-created and should persist\n        logger.info(\"Preserving user-created draft schedules...\")\n\n        # Now clear all ETL tables in reverse dependency order to avoid foreign key constraints\n        # Use raw SQL DELETE to avoid ORM schema mismatches (e.g., clusters.theme column issue)\n        logger.info(\"Clearing existing data from ETL tables (in reverse dependency order)...\")\n\n        # First, rollback any existing failed transaction\n        try:\n            db.rollback()\n        except:\n            pass\n\n        for table_name in reversed(LOAD_ORDER):\n            model_class = TABLE_MODELS[table_name]\n            table_name_db = model_class.__tablename__\n\n            try:\n                # Check if table exists\n                inspector = inspect(db.bind)\n                table_names = inspector.get_table_names()\n\n                if table_name_db not in table_names:\n                    logger.debug(f\"Table {table_name_db} does not exist yet, skipping clear\")\n                    continue\n\n                # Use raw SQL DELETE to avoid ORM schema mismatches\n                # This bypasses any column mismatch issues (e.g., missing theme column in clusters)\n                try:\n                    # Start a savepoint for this table's operation\n                    db.begin_nested()\n                    result = db.execute(text(f'DELETE FROM \"{table_name_db}\"'))\n                    deleted_count = result.rowcount\n                    db.commit()  # Commit the nested transaction\n\n                    if deleted_count &gt; 0:\n                        logger.info(f\"Cleared {deleted_count} records from {table_name} ({table_name_db})\")\n                    else:\n                        logger.debug(f\"Table {table_name} ({table_name_db}) is already empty\")\n                except Exception as delete_error:\n                    # Rollback the nested transaction and continue\n                    db.rollback()\n                    logger.warning(f\"Could not clear {table_name} ({table_name_db}): {delete_error}. Continuing...\")\n                    continue\n\n            except Exception as e:\n                logger.warning(f\"Error checking/clearing {table_name} ({table_name_db}): {e}. Continuing...\")\n                try:\n                    db.rollback()\n                except:\n                    pass\n                continue\n\n        # Final commit for any remaining operations\n        try:\n            db.commit()\n            logger.info(\"All existing data cleared. Loading fresh data...\")\n        except Exception as e:\n            logger.warning(f\"Error in final commit: {e}. Rolling back...\")\n            db.rollback()\n\n        # Now load tables in dependency order\n        data_dir = \"data\"\n        total_records = 0\n        failed_tables = []\n        successful_tables = []\n\n        for table_name in LOAD_ORDER:\n            csv_path = os.path.join(data_dir, f\"{table_name}.csv\")\n            model_class = TABLE_MODELS[table_name]\n\n            logger.info(f\"{'=' * 60}\")\n            logger.info(f\"Loading {table_name} (table: {model_class.__tablename__})...\")\n            logger.info(f\"CSV path: {csv_path}\")\n\n            try:\n                # Verify CSV file exists before attempting to load\n                if not os.path.exists(csv_path):\n                    error_msg = f\"CSV file not found: {csv_path}\"\n                    logger.error(f\"\u274c {error_msg}\")\n                    logger.error(f\"   Current working directory: {os.getcwd()}\")\n                    logger.error(f\"   Data directory: {os.path.abspath(data_dir)}\")\n                    logger.error(f\"   Files in data directory: {os.listdir(data_dir) if os.path.exists(data_dir) else 'Directory does not exist'}\")\n                    failed_tables.append(table_name)\n                    continue  # Don't raise, continue to next table\n\n                # Check if CSV file is empty\n                file_size = os.path.getsize(csv_path)\n                if file_size == 0:\n                    error_msg = f\"CSV file is empty: {csv_path}\"\n                    logger.error(f\"\u274c {error_msg}\")\n                    failed_tables.append(table_name)\n                    continue  # Don't raise, continue to next table\n\n                logger.info(f\"   CSV file found ({file_size} bytes)\")\n\n                count = load_csv_to_db(csv_path, model_class, db)\n                if count == 0:\n                    logger.warning(f\"\u26a0\ufe0f  WARNING: {table_name} loaded 0 records. Check if CSV file exists and has data.\")\n                    logger.warning(f\"   CSV path: {csv_path}\")\n                    logger.warning(f\"   File size: {file_size} bytes\")\n                    failed_tables.append(table_name)\n                else:\n                    logger.info(f\"\u2713 Successfully loaded {count} records into {model_class.__tablename__}\")\n                    successful_tables.append(table_name)\n                total_records += count\n            except Exception as e:\n                logger.error(f\"\u274c FAILED to load {table_name}: {e}\")\n                logger.error(f\"   CSV path: {csv_path}\")\n                logger.error(f\"   Model: {model_class.__name__}, Table: {model_class.__tablename__}\")\n                logger.error(f\"   Error type: {type(e).__name__}\")\n                import traceback\n                logger.error(f\"   Traceback: {traceback.format_exc()}\")\n                logger.error(f\"   Continuing to next table...\")\n                failed_tables.append(table_name)\n                # Rollback failed transaction and continue\n                try:\n                    db.rollback()\n                except:\n                    pass\n                continue  # Don't raise, continue to next table\n\n        logger.info(f\"\\n{'=' * 60}\")\n        logger.info(f\"Data Loading Summary:\")\n        logger.info(f\"{'=' * 60}\")\n        logger.info(f\"Total records loaded: {total_records}\")\n        logger.info(f\"Successful tables: {len(successful_tables)}/{len(LOAD_ORDER)}\")\n        logger.info(f\"Failed tables: {len(failed_tables)}/{len(LOAD_ORDER)}\")\n\n        if successful_tables:\n            logger.info(f\"\\n\u2705 Successfully loaded tables:\")\n            for table in successful_tables:\n                logger.info(f\"   - {table}\")\n\n        if failed_tables:\n            logger.warning(f\"\\n\u274c Failed tables:\")\n            for table in failed_tables:\n                logger.warning(f\"   - {table}\")\n            logger.warning(f\"\\nTo fix: docker compose down -v &amp;&amp; docker compose up -d\")\n            # Exit with error code if critical tables failed\n            critical_tables = [\"location\", \"student\", \"instructor\", \"course\", \"section\"]\n            failed_critical = [t for t in failed_tables if t in critical_tables]\n            if failed_critical:\n                logger.error(f\"\\n\u274c CRITICAL tables failed: {failed_critical}\")\n                logger.error(f\"Database is incomplete and may not function properly!\")\n                raise Exception(f\"Critical tables failed to load: {failed_critical}\")\n        else:\n            logger.info(f\"\\n{'=' * 60}\")\n            logger.info(f\"\u2705 SUCCESS: All tables loaded successfully!\")\n            logger.info(f\"{'=' * 60}\")\n\n            # Automatically generate recommendations for all students\n            logger.info(f\"\\n{'=' * 60}\")\n            logger.info(f\"Generating recommendations for all students...\")\n            logger.info(f\"{'=' * 60}\")\n            try:\n                generate_recommendations_for_all_students(db)\n                logger.info(f\"\u2705 Recommendations generated successfully!\")\n            except Exception as e:\n                logger.warning(f\"\u26a0\ufe0f  Could not generate recommendations: {e}\")\n                logger.warning(f\"   Students can still generate recommendations via the frontend\")\n                # Don't fail the ETL process if recommendations fail\n\n    except Exception as e:\n        logger.error(f\"Error during data loading: {e}\")\n        try:\n            db.rollback()\n        except:\n            pass\n        raise\n    finally:\n        db.close()\n</code></pre>"},{"location":"etl/#etl-database-models","title":"ETL Database Models","text":"<p>Database models for the university ETL schema.</p>"},{"location":"etl/#university_app.etl.Database.models.Cluster","title":"<code>Cluster</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents an academic cluster (thematic groupings of courses).</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Cluster(Base):\n    \"\"\"\n    Description: Represents an academic cluster (thematic groupings of courses).\n    \"\"\"\n    __tablename__ = \"clusters\"\n\n    cluster_id = Column(Integer, primary_key=True)\n    cluster_number = Column(Integer, nullable=True)\n    theme = Column(String(500), nullable=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Course","title":"<code>Course</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a course with its credits.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Course(Base):\n    \"\"\"\n    Description: Represents a course with its credits.\n    \"\"\"\n    __tablename__ = \"courses\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    credits = Column(Integer, nullable=False)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.CourseCluster","title":"<code>CourseCluster</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Junction table linking courses to clusters (many-to-many).</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class CourseCluster(Base):\n    \"\"\"Description: Junction table linking courses to clusters (many-to-many).\"\"\"\n    __tablename__ = \"course_cluster\"\n\n    course_id = Column(Integer, ForeignKey(\"courses.id\"), primary_key=True)\n    cluster_id = Column(Integer, ForeignKey(\"clusters.cluster_id\"), primary_key=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Department","title":"<code>Department</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents an academic department and its main office location.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Department(Base):\n    \"\"\"Description: Represents an academic department and its main office location.\"\"\"\n    __tablename__ = \"departments\"\n\n    dept_name = Column(String, primary_key=True)\n    roomID = Column(Integer, ForeignKey(\"locations.room_id\"))\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.DraftSchedule","title":"<code>DraftSchedule</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for draft schedules created by students.</p> <p>Stores draft schedule metadata. The actual sections in each schedule are stored in the draft_schedule_sections junction table.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class DraftSchedule(Base):\n    \"\"\"\n    Database model for draft schedules created by students.\n\n    Stores draft schedule metadata. The actual sections in each schedule\n    are stored in the draft_schedule_sections junction table.\n    \"\"\"\n    __tablename__ = \"draft_schedules\"\n\n    draft_schedule_id = Column(Integer, primary_key=True, autoincrement=True, index=True)\n    student_id = Column(Integer, ForeignKey(\"students.student_id\"), nullable=False, index=True)\n    name = Column(String(100), nullable=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False, index=True)\n    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.DraftScheduleSection","title":"<code>DraftScheduleSection</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for draft_schedule_sections junction table.</p> <p>Links draft schedules to sections (many-to-many relationship).</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class DraftScheduleSection(Base):\n    \"\"\"\n    Database model for draft_schedule_sections junction table.\n\n    Links draft schedules to sections (many-to-many relationship).\n    \"\"\"\n    __tablename__ = \"draft_schedule_sections\"\n\n    draft_schedule_id = Column(Integer, ForeignKey(\"draft_schedules.draft_schedule_id\", ondelete=\"CASCADE\"), primary_key=True, nullable=False, index=True)\n    section_id = Column(Integer, ForeignKey(\"sections.id\", ondelete=\"CASCADE\"), primary_key=True, nullable=False, index=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.HasCourse","title":"<code>HasCourse</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Junction table linking programs to the courses they include.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class HasCourse(Base):\n    \"\"\"Description: Junction table linking programs to the courses they include.\"\"\"\n    __tablename__ = \"hascourse\"\n\n    prog_name = Column(String, ForeignKey(\"programs.prog_name\"), primary_key=True)\n    courseid = Column(Integer, ForeignKey(\"courses.id\"), primary_key=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Instructor","title":"<code>Instructor</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents an instructor and their assigned office location.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Instructor(Base):\n    \"\"\"\n    Description: Represents an instructor and their assigned office location.\n    \"\"\"\n    __tablename__ = \"instructors\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(String(100), nullable=False)\n    bio_url = Column(String(255), nullable=True)\n    room_id = Column(Integer, ForeignKey(\"locations.room_id\"), nullable=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Location","title":"<code>Location</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a physical room or location within the university.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Location(Base):\n    \"\"\"\n    Description: Represents a physical room or location within the university.\n    \"\"\"\n    __tablename__ = \"locations\"\n\n    room_id = Column(Integer, primary_key=True)\n    building_room_name = Column(String(100), nullable=False)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Preferred","title":"<code>Preferred</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a student's preferred courses.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Preferred(Base):\n    \"\"\"Description: Represents a student's preferred courses.\"\"\"\n    __tablename__ = \"preferred\"\n\n    student_id = Column(\n        Integer, ForeignKey(\"students.student_id\"), primary_key=True\n    )\n    course_id = Column(\n        Integer, ForeignKey(\"courses.id\"), primary_key=True\n    )\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Prerequisites","title":"<code>Prerequisites</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Junction table linking a course to its prerequisite courses.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Prerequisites(Base):\n    \"\"\"Description: Junction table linking a course to its prerequisite courses.\"\"\"\n    __tablename__ = \"prerequisites\"\n\n    course_id = Column(Integer, ForeignKey(\"courses.id\"), primary_key=True)\n    prerequisite_id = Column(Integer, ForeignKey(\"courses.id\"), primary_key=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Program","title":"<code>Program</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents an academic program offered by a department.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Program(Base):\n    \"\"\"\n    Description: Represents an academic program offered by a department.\n    \"\"\"\n    __tablename__ = \"programs\"\n\n    prog_name = Column(String, primary_key=True)\n    dept_name = Column(String(50), ForeignKey(\"departments.dept_name\"), nullable=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.RecommendationResult","title":"<code>RecommendationResult</code>","text":"<p>               Bases: <code>Base</code></p> <p>Database model for storing semester recommendation results from the notebook. Matches API model structure for compatibility.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class RecommendationResult(Base):\n    \"\"\"\n    Database model for storing semester recommendation results from the notebook.\n    Matches API model structure for compatibility.\n    \"\"\"\n    __tablename__ = \"recommendation_results\"\n\n    id = Column(Integer, primary_key=True, autoincrement=True, index=True)\n\n    # Foreign keys\n    student_id = Column(Integer, ForeignKey(\"students.student_id\"), nullable=False, index=True)\n    course_id = Column(Integer, ForeignKey(\"courses.id\"), nullable=True)\n    recommended_section_id = Column(Integer, ForeignKey(\"sections.id\"), nullable=False)\n    time_slot = Column(Integer, ForeignKey(\"time_slots.time_slot_id\"), nullable=True)\n\n    course_name = Column(String(200), nullable=True)\n    cluster = Column(String(200), nullable=True)\n    credits = Column(Integer, nullable=True)\n\n    # Recommendation logic\n    recommendation_score = Column(String(50), nullable=True)\n    why_recommended = Column(String(1000), nullable=True)\n    slot_number = Column(Integer, nullable=True)\n\n    # Model and context\n    model_version = Column(String(50), nullable=True)\n    time_preference = Column(String(20), nullable=True)\n    semester = Column(String(20), nullable=True)\n    year = Column(Integer, nullable=True)\n\n    # Timestamps\n    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Section","title":"<code>Section</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a specific course section in a time slot (which includes year and semester).</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Section(Base):\n    \"\"\"\n    Description: Represents a specific course section in a time slot (which includes year and semester).\n    \"\"\"\n    __tablename__ = \"sections\"\n\n    id = Column(Integer, primary_key=True)\n    capacity = Column(Integer, nullable=False)\n    roomID = Column(Integer, ForeignKey(\"locations.room_id\"), nullable=False)\n    duration = Column(String(50), nullable=True)\n    time_slot_id = Column(Integer, ForeignKey(\"time_slots.time_slot_id\"), nullable=False)\n    course_id = Column(Integer, ForeignKey(\"courses.id\"), nullable=False)\n    instructor_id = Column(Integer, ForeignKey(\"instructors.id\"), nullable=False)\n    syllabus_url = Column(String(255), nullable=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.SectionName","title":"<code>SectionName</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents section names/letters linked to sections.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class SectionName(Base):\n    \"\"\"\n    Description: Represents section names/letters linked to sections.\n    \"\"\"\n    __tablename__ = \"section_name\"\n\n    section_name = Column(String, primary_key=True)  # section_letter\n    section_id = Column(Integer, ForeignKey(\"sections.id\"), primary_key=True, nullable=False)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Student","title":"<code>Student</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a student and their core attributes in the university system.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Student(Base):\n    \"\"\"\n    Description: Represents a student and their core attributes in the university system.\n    \"\"\"\n    __tablename__ = \"students\"\n\n    student_id = Column(Integer, primary_key=True)\n    student_name = Column(String(100), nullable=False)\n    credit = Column(Integer, nullable=True)\n    program_name = Column(String(100), nullable=False)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Takes","title":"<code>Takes</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Junction table storing which student takes which section and their status/grade.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Takes(Base):\n    \"\"\"Description: Junction table storing which student takes which section and their status/grade.\"\"\"\n    __tablename__ = \"takes\"\n\n    student_id = Column(\n        Integer, ForeignKey(\"students.student_id\"), primary_key=True\n    )\n    section_id = Column(Integer, ForeignKey(\"sections.id\"), primary_key=True)\n    status = Column(String(20))  # e.g., 'enrolled', 'completed', 'dropped'\n    grade = Column(String(5), nullable=True)  # e.g., 'A', 'B+', 'F', 'P', 'NP'\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.TimeSlot","title":"<code>TimeSlot</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a time slot with day, start/end times, year, and semester.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class TimeSlot(Base):\n    \"\"\"\n    Description: Represents a time slot with day, start/end times, year, and semester.\n    \"\"\"\n    __tablename__ = \"time_slots\"\n\n    time_slot_id = Column(Integer, primary_key=True)\n    day_of_week = Column(String(3), nullable=False)\n    start_time = Column(String, nullable=False)\n    end_time = Column(String, nullable=False)\n    year = Column(Integer, nullable=False)\n    semester = Column(String, nullable=False)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.User","title":"<code>User</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Represents a user with login credentials linked to a student.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class User(Base):\n    \"\"\"\n    Description: Represents a user with login credentials linked to a student.\n    \"\"\"\n    __tablename__ = \"users\"\n\n    user_id = Column(Integer, primary_key=True)\n    username = Column(String(50), nullable=False, unique=True)\n    password = Column(String(70), nullable=False, unique=True)\n    student_id = Column(Integer, ForeignKey(\"students.student_id\"), nullable=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.Works","title":"<code>Works</code>","text":"<p>               Bases: <code>Base</code></p> <p>Description: Junction table storing which instructor works in which department.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>class Works(Base):\n    \"\"\"Description: Junction table storing which instructor works in which department.\"\"\"\n    __tablename__ = \"works\"\n\n    instructorid = Column(Integer, ForeignKey(\"instructors.id\"), primary_key=True)\n    dept_name = Column(String, ForeignKey(\"departments.dept_name\"), primary_key=True)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.check_schema_version","title":"<code>check_schema_version()</code>","text":"<p>Check if database schema matches current models. Returns True if schema is up to date, False if recreation needed.</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>def check_schema_version():\n    \"\"\"\n    Check if database schema matches current models.\n    Returns True if schema is up to date, False if recreation needed.\n    \"\"\"\n    try:\n        inspector = inspect(engine)\n        existing_tables = inspector.get_table_names()\n\n        # Define expected schema for critical tables\n        schema_checks = {\n            'clusters': ['cluster_id', 'cluster_number', 'theme'],\n            'users': ['user_id', 'username', 'password', 'student_id'],\n            'students': ['student_id', 'student_name', 'credit', 'program_name'],\n            'sections': ['id', 'capacity', 'roomID', 'duration', 'time_slot_id', 'course_id', 'instructor_id', 'syllabus_url'],\n            'draft_schedules': ['draft_schedule_id', 'student_id', 'name', 'created_at', 'updated_at'],\n            'draft_schedule_sections': ['draft_schedule_id', 'section_id'],\n        }\n\n        for table_name, expected_columns in schema_checks.items():\n            if table_name in existing_tables:\n                actual_columns = [col['name'] for col in inspector.get_columns(table_name)]\n                # Check if all expected columns exist\n                missing_columns = [col for col in expected_columns if col not in actual_columns]\n                if missing_columns:\n                    print(f\"\u26a0\ufe0f  Schema mismatch in '{table_name}': missing columns {missing_columns}\")\n                    return False\n\n        # Check for old 'user' table (reserved word issue)\n        if 'user' in existing_tables:\n            print(\"\u26a0\ufe0f  Found old 'user' table (PostgreSQL reserved word)\")\n            return False\n\n        return True\n\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Could not check schema version: {e}\")\n        return False  # Assume recreation needed on error\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.create_tables","title":"<code>create_tables()</code>","text":"Description <p>Creates all database tables defined by the ORM models for ETL/testing.</p> <p>Automatically detects schema mismatches and recreates tables if needed.</p> Input <p>None</p> Output <p>None (the function issues CREATE TABLE statements via SQLAlchemy metadata)</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>def create_tables():\n    \"\"\"\n    Description:\n        Creates all database tables defined by the ORM models for ETL/testing.\n    Automatically detects schema mismatches and recreates tables if needed.\n\n    Input:\n        None\n\n    Output:\n        None (the function issues CREATE TABLE statements via SQLAlchemy metadata)\n    \"\"\"\n    print(\"=\" * 60)\n    print(\"Checking database schema...\")\n    print(\"=\" * 60)\n\n    inspector = inspect(engine)\n    existing_tables = inspector.get_table_names()\n\n    # If no tables exist, just create them\n    if not existing_tables:\n        print(\"No existing tables found. Creating fresh database...\")\n        Base.metadata.create_all(bind=engine)\n        print(\"\u2705 All tables created successfully\")\n        return\n\n    # Check if schema matches current models\n    schema_ok = check_schema_version()\n\n    if not schema_ok:\n        print(\"\\n\u26a0\ufe0f  Schema mismatch detected. Recreating all tables with correct schema...\")\n        print(\"   This will delete all existing data and reload from CSV files.\")\n\n        # Drop all tables\n        if drop_all_tables():\n            # Create tables with correct schema\n            Base.metadata.create_all(bind=engine)\n            print(\"\u2705 All tables recreated with correct schema\")\n        else:\n            print(\"\u274c Failed to drop tables. Attempting to create missing tables...\")\n            Base.metadata.create_all(bind=engine)\n    else:\n        # Schema is fine, just create any missing tables\n        print(\"\u2705 Schema is up to date. Creating any missing tables...\")\n        Base.metadata.create_all(bind=engine)\n        print(\"\u2705 Database tables verified\")\n\n    print(\"=\" * 60)\n</code></pre>"},{"location":"etl/#university_app.etl.Database.models.drop_all_tables","title":"<code>drop_all_tables()</code>","text":"<p>Drop all ETL-managed tables in the database. Used for clean recreation. Preserves user-generated tables: draft_schedules, draft_schedule_sections, recommendation_results</p> Source code in <code>university_app/etl/Database/models.py</code> <pre><code>def drop_all_tables():\n    \"\"\"\n    Drop all ETL-managed tables in the database. Used for clean recreation.\n    Preserves user-generated tables: draft_schedules, draft_schedule_sections, recommendation_results\n    \"\"\"\n    # ETL-managed tables (must match LOAD_ORDER in load_data_to_db.py)\n    ETL_TABLES = {\n        \"users\", \"students\", \"locations\", \"instructors\", \"departments\", \n        \"programs\", \"courses\", \"time_slots\", \"sections\", \"section_name\",\n        \"prerequisites\", \"takes\", \"works\", \"hascourse\", \"clusters\", \n        \"course_cluster\", \"preferred\"\n    }\n\n    # User-generated tables to preserve (draft schedules are user-created and should persist)\n    # Note: recommendation_results are cleared separately in load_data_to_db.py \n    # because they reference sections that may change\n    PRESERVE_TABLES = {\n        \"draft_schedules\", \"draft_schedule_sections\"\n    }\n\n    # Orphaned/legacy tables to drop (no longer in codebase)\n    ORPHANED_TABLES = {\n        \"ab_test_assignments\", \"ui_element_clicks\"\n    }\n\n    print(\"\u26a0\ufe0f  Dropping ETL-managed tables for clean recreation...\")\n    print(\"   Preserving user-generated tables: draft_schedules, draft_schedule_sections\")\n    print(\"   Dropping orphaned tables: ab_test_assignments, ui_element_clicks\")\n\n    try:\n        with engine.connect() as connection:\n            # Disable foreign key checks temporarily\n            connection.execute(text(\"SET session_replication_role = 'replica';\"))\n\n            # Get all tables\n            inspector = inspect(engine)\n            all_tables = inspector.get_table_names()\n\n            # Drop ETL-managed tables and orphaned tables\n            dropped_count = 0\n            for table in all_tables:\n                # Normalize table name (handle case sensitivity)\n                table_lower = table.lower()\n                if table_lower in ETL_TABLES:\n                    print(f\"   Dropping ETL table: {table}\")\n                    connection.execute(text(f'DROP TABLE IF EXISTS \"{table}\" CASCADE'))\n                    dropped_count += 1\n                elif table_lower in ORPHANED_TABLES:\n                    print(f\"   Dropping orphaned table: {table}\")\n                    connection.execute(text(f'DROP TABLE IF EXISTS \"{table}\" CASCADE'))\n                    dropped_count += 1\n                elif table_lower in PRESERVE_TABLES:\n                    print(f\"   Preserving user table: {table}\")\n                else:\n                    # Unknown table - preserve it to be safe\n                    print(f\"   Preserving unknown table: {table}\")\n\n            # Re-enable foreign key checks\n            connection.execute(text(\"SET session_replication_role = 'origin';\"))\n            connection.commit()\n\n        print(f\"\u2713 Dropped {dropped_count} ETL-managed tables successfully\")\n        print(\"\u2713 User-generated tables preserved\")\n        return True\n\n    except Exception as e:\n        print(f\"\u274c Error dropping tables: {e}\")\n        return False\n</code></pre>"},{"location":"etl/#database-configuration","title":"Database Configuration","text":"<p>Database configuration for the ETL process.</p>"},{"location":"etl/#university_app.etl.Database.database.get_db","title":"<code>get_db()</code>","text":"Description <p>Provides a database session for performing ORM operations and closes it when done.</p> Input <p>None</p> Output <p>Generator that yields a <code>sqlalchemy.orm.Session</code> instance</p> Source code in <code>university_app/etl/Database/database.py</code> <pre><code>def get_db() -&gt; Generator[orm.Session, None, None]:\n    \"\"\"\n    Description:\n        Provides a database session for performing ORM operations and closes it when done.\n\n    Input:\n        None\n\n    Output:\n        Generator that yields a `sqlalchemy.orm.Session` instance\n    \"\"\"\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n</code></pre>"}]}